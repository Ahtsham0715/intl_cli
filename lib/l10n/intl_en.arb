{
  "instead": " instead",
  "dart": ".dart",
  "directoryNotFoundNormalizeddir": "Directory not found: $normalizedDir",
  "errorScanningDirectoryE": "ERROR scanning directory: $e",
  "errorDirectoryNotFoundInScanNormalizeddirOriginalDirectory": "ERROR: Directory not found in scan: $normalizedDir (original: $directory)",
  "errorDirectoryNotFoundInScanasyncNormalizeddirOriginalDirectory": "ERROR: Directory not found in scanAsync: $normalizedDir (original: $directory)",
  "warningCommandNameDetectedAsDirectoryInFilescannerUsing": "WARNING: Command name detected as directory in FileScanner, using ",
  "dartAsync": "dart:async",
  "dartIo": "dart:io",
  "stringSingularformValueReplaceall": "\n        String singularForm = value\n            .replaceAll(",
  "returnUpdatedCleanArbFileByRemovingEntriesWithInvalidIcuSyntaxDartInterpolationStaticVoidCleaninvalidentriesStringFilepathFinalFileFileFilepathIfFileExistssyncPrint": "\n        };\n      }\n    });\n    return updated;\n  }\n\n  /// Clean ARB file by removing entries with invalid ICU syntax (Dart interpolation)\n  static void cleanInvalidEntries(String filePath) {\n    final file = File(filePath);\n    if (!file.existsSync()) {\n      print(",
  "finalUpdatedStringDynamicArbdataForeachKeyValueUpdatedKeyValueIfAmbiguousContainsKeyTolowercaseValueIsStringAmbiguousContainsValueTolowercaseUpdated": "\n    };\n    final updated = <String, dynamic>{};\n    arbData.forEach((key, value) {\n      updated[key] = value;\n      if (ambiguous.contains(key.toLowerCase()) ||\n          (value is String && ambiguous.contains(value.toLowerCase()))) {\n        updated[",
  "forPluralReplaceallRegexpR": " for plural\n          .replaceAll(RegExp(r",
  "or": " or ",
  "key": "$key",
  "s": {
    "one": "",
    "other": "s"
  },
  "replaceallRegexpR": ")\n            .replaceAll(RegExp(r",
  "add": ")  // Add ",
  "normalizeToPluralFormTrimReturnThePluralFormsAsAMapReturnStringString": ")  // Normalize to plural form\n          .trim();\n\n      // Return the plural forms as a Map\n      return <String, String>{\n        ",
  "normalizeToSingularFormTrimCreatePluralFormStringPluralformBasevalueReplaceall": ")  // Normalize to singular form\n          .trim();\n\n      // Create plural form\n      String pluralForm = baseValue\n          .replaceAll(",
  "removeSForSingularReplaceallRegexpR": {
    "one": ")  // Remove  for singular\n          .replaceAll(RegExp(r",
    "other": ")  // Remove s for singular\n          .replaceAll(RegExp(r"
  },
  "valueContains": ") ||\n          (value.contains(",
  "regexpR": ") ||\n          RegExp(r",
  "valueContains_1": ") ||\n          value.contains(",
  "valueTolowercaseContains": ") ||\n          value.toLowerCase().contains(",
  "explicitCountPlaceholderRegexpR": ") || // Explicit count placeholder\n           RegExp(r",
  "explicitPluralIndicatorValueContains": ") || // Explicit plural indicator\n           value.contains(",
  "valueContains_2": ") || value.contains(",
  "maleformValueReplaceallRegexpR": ")) {\n          maleForm =\n              value.replaceAll(RegExp(r",
  "maleformMaleformReplaceallRegexpR": ")) {\n          maleForm = maleForm.replaceAll(\n              RegExp(r",
  "maleformValueReplaceallRegexpR_1": ")) {\n          maleForm = value.replaceAll(RegExp(r",
  "normalizeTheBaseStringFirstStringBasevalueValueReplaceallRegexpR": ")) {\n      // Normalize the base string first\n      String baseValue = value.replaceAll(RegExp(r",
  "valueContains_3": ")) ||\n          (value.contains(",
  "detectGenderPatternsBoolContainsgenderValueTolowercaseContains": "));\n\n      // Detect gender patterns\n      bool containsGender = value.toLowerCase().contains(",
  "emptyString": "),\n        ",
  "emptyString_1": "), ",
  "r": "), r",
  "convertArbdataFileWriteasstringsyncCleanedcontentPrint": ").convert(arbData);\n        file.writeAsStringSync(cleanedContent);\n\n        print(",
  "convertArbdataFileWriteasstringsyncArbcontentIfNewadded0Print": ").convert(arbData);\n    file.writeAsStringSync(arbContent);\n\n    if (newAdded > 0) {\n      print(",
  "hasmatchValueBoolContainspluralValueContains": ").hasMatch(value);\n\n      bool containsPlural = value.contains(",
  "hasmatchValueExplicitNumbersWithPluralsGeneratePluralOrGenderVariationsForAStringThatNeedsItStaticDynamicGeneratepluralorgendervalueStringValueHandlePluralFormsFirstIfValueContains": ").hasMatch(value); // Explicit numbers with plurals\n  }\n\n  /// Generate plural or gender variations for a string that needs it\n  static dynamic _generatePluralOrGenderValue(String value) {\n    // Handle plural forms first\n    if (value.contains(",
  "stringPluralformValueReplaceall": ");\n\n        String pluralForm = value\n            .replaceAll(",
  "resultEntryKey": ");\n\n        result[entry.key] = {\n          ",
  "createSingularFormStringSingularformBasevalueReplaceall": ");\n\n      // Create singular form\n      String singularForm = baseValue\n          .replaceAll(",
  "finalKeystoremoveStringFindEntriesWithInvalidIcuSyntaxArbdataForeachKeyValueIfValueIsStringDartinterpolationpatternHasmatchValueKeystoremoveAddKeyPrint": ");\n\n      final keysToRemove = <String>[];\n\n      // Find entries with invalid ICU syntax\n      arbData.forEach((key, value) {\n        if (value is String && dartInterpolationPattern.hasMatch(value)) {\n          keysToRemove.add(key);\n          print(",
  "ifContainscountContainspluralExample": ");\n\n      if (containsCount && containsPlural) {\n        // Example: ",
  "femaleformValueReplaceallRegexpR": ");\n          femaleForm =\n              value.replaceAll(RegExp(r",
  "femaleformFemaleformReplaceallRegexpR": ");\n          femaleForm = femaleForm.replaceAll(\n              RegExp(r",
  "femaleformValueReplaceallRegexpR_1": ");\n          femaleForm = value.replaceAll(\n              RegExp(r",
  "otherformValueReplaceallRegexpR": ");\n          otherForm =\n              value.replaceAll(RegExp(r",
  "otherformOtherformReplaceallRegexpR": ");\n          otherForm = otherForm.replaceAll(\n              RegExp(r",
  "otherformValueReplaceallRegexpR_1": ");\n          otherForm = value.replaceAll(\n              RegExp(r",
  "print": ");\n        print(",
  "handlePossessivePronounsIfValueTolowercaseContains": ");\n        }\n\n        // Handle possessive pronouns\n        if (value.toLowerCase().contains(",
  "writeCleanedArbFileFinalCleanedcontentJsonencoderWithindent": ");\n        }\n\n        // Write cleaned ARB file\n        final cleanedContent = JsonEncoder.withIndent(",
  "resultEntryKey_1": ");\n        }\n\n        result[entry.key] = {\n          ",
  "removeInvalidEntriesIfKeystoremoveIsnotemptyForFinalKeyInKeystoremoveArbdataRemoveKeyAlsoRemoveAssociatedMetadataIfItExistsArbdataRemove": ");\n        }\n      });\n\n      // Remove invalid entries\n      if (keysToRemove.isNotEmpty) {\n        for (final key in keysToRemove) {\n          arbData.remove(key);\n          // Also remove associated metadata if it exists\n          arbData.remove(",
  "elseIfValueTolowercaseContains": ");\n        } else if (value.toLowerCase().contains(",
  "returnTryFinalContentFileReadasstringsyncFinalArbdataJsondecodeContentAsMapStringDynamicPatternToDetectDartStringInterpolationFinalDartinterpolationpatternRegexpR": ");\n      return;\n    }\n\n    try {\n      final content = file.readAsStringSync();\n      final arbData = jsonDecode(content) as Map<String, dynamic>;\n\n      // Pattern to detect Dart string interpolation\n      final dartInterpolationPattern = RegExp(r",
  "catchEPrint": ");\n      }\n    } catch (e) {\n      print(",
  "elsePrint": ");\n      } else {\n        print(",
  "addContextNotesAndSaveArbdataAddcontextnotesArbdataVarArbcontentJsonencoderWithindent": ");\n    // Add context notes and save\n    arbData = addContextNotes(arbData);\n    var arbContent = JsonEncoder.withIndent(",
  "checksIfAStringNeedsPluralOrGenderSupportStaticBoolNeedspluralorgendersupportStringValueOnlyReturnTrueIfThereAreExplicitIndicatorsReturnValueContains": ");\n    }\n  }\n\n\n\n  /// Checks if a string needs plural or gender support\n  static bool _needsPluralOrGenderSupport(String value) {\n    // Only return true if there are explicit indicators\n    return value.contains(",
  "elsePrint_1": ");\n    } else {\n      print(",
  "emptyString_2": ",\n      ",
  "boolSuggestmeaningfulkeysTrueStringKeyformat": ",\n    bool suggestMeaningfulKeys = true,\n    String keyFormat = ",
  "optionsSnakeCaseCamelcaseDotCaseFinalFileFileFilepathCreateDirectoryIfItDoesn": ", // Options: snake_case, camelCase, dot.case\n  }) {\n    final file = File(filePath);\n\n    // Create directory if it doesn",
  "casesensitiveFalse": ", caseSensitive: false),\n              ",
  "casesensitiveFalse_1": ", caseSensitive: false), ",
  "casesensitiveFalseHasmatchValueGenderIndicatorsRegexpR": ", caseSensitive: false).hasMatch(value) || // Gender indicators\n           RegExp(r",
  "casesensitiveFalseHasmatchValueHandleGenderVariationsReturnStringString": ", caseSensitive: false).hasMatch(value)) {\n      // Handle gender variations\n      return <String, String>{\n        ",
  "emptyString_3": ":\n              ",
  "femaleform": ": femaleForm,\n          ",
  "maleform": ": maleForm,\n          ",
  "otherformElseResultEntryKeyValueReturnResultScanForAmbiguousOrRepetitiveStringsAndAddContextNotesStaticMapStringDynamicAddcontextnotesMapStringDynamicArbdataFinalAmbiguous": ": otherForm,\n        };\n      } else {\n        result[entry.key] = value;\n      }\n    }\n    return result;\n  }\n\n  /// Scan for ambiguous or repetitive strings and add context notes\n  static Map<String, dynamic> addContextNotes(Map<String, dynamic> arbData) {\n    final ambiguous = {\n      ",
  "pluralformElseIfContainsgenderCreateGenderVariationsWithIcuSyntaxStringMaleformValueStringFemaleformValueStringOtherformValueReplaceGenderPronounsWithIcuSyntaxIfValueTolowercaseContains": ": pluralForm,\n        };\n      } else if (containsGender) {\n        // Create gender variations with ICU syntax\n        String maleForm = value;\n        String femaleForm = value;\n        String otherForm = value;\n\n        // Replace gender pronouns with ICU syntax\n        if (value.toLowerCase().contains(",
  "pluralformElseIfRegexpR": ": pluralForm,\n      };\n    } else if (RegExp(r",
  "singularform": ": singularForm,\n        ",
  "singularform_1": ": singularForm,\n          ",
  "valueReturnValueDetectPluralGenderPatternsAndGenerateArbEntriesAccordinglyStaticMapStringDynamicAddpluralandgendersupportMapStringStringNewstringsFinalResultStringDynamicForFinalEntryInNewstringsEntriesFinalValueEntryValueCheckForPotentialPluralPatternsBoolContainscountValueTolowercaseContains": ": value,\n      };\n    }\n\n    return value;\n  }\n\n  /// Detect plural/gender patterns and generate ARB entries accordingly\n  static Map<String, dynamic> addPluralAndGenderSupport(\n      Map<String, String> newStrings) {\n    final result = <String, dynamic>{};\n    for (final entry in newStrings.entries) {\n      final value = entry.value;\n\n      // Check for potential plural patterns\n      bool containsCount = value.toLowerCase().contains(",
  "valueReplaceallRegexpR": ": value.replaceAll(RegExp(r",
  "creatingANewArbFileInstead": "Creating a new ARB file instead.",
  "emptyString_4": "] = {\n          ",
  "dartConvert": "dart:convert",
  "dartIo_1": "dart:io",
  "sNewOrAnUpdateArbdataKeyProcessedvalueNewaddedPrint": "s new or an update\n      arbData[key] = processedValue;\n      newAdded++;\n    }\n\n    print(",
  "count": {
    "one": "{count}",
    "other": "{count}"
  },
  "errorReadingExistingArbFileE": "⚠️ Error reading existing ARB file: $e",
  "generatedValueProcessedvalue": "✏️ Generated value: $processedValue",
  "processingValueValueForKeyKey": "📍 Processing value: $value for key: $key",
  "mergingWithExistingArbFileFilePath": "📝 Merging with existing ARB file: ${file.path}",
  "currentdirPathIsnotemptyFinalPubspecFile": " && currentDir.path.isNotEmpty) {\n        final pubspec = File(",
  "emptyString_5": " : ",
  "isSetFinalPubspecfileFindpubspecfileProjectrootIfPubspecfileNullPrint": " is set\n    final pubspecFile = _findPubspecFile(projectRoot);\n    if (pubspecFile == null) {\n      print(",
  "toApplyPubspecYamlChangesU001b0m": " to apply pubspec.yaml changes\\u001b[0m",
  "toPubspecYamlFlutterSectionU001b0m": " to pubspec.yaml flutter section\\u001b[0m",
  "toUpdateDependenciesU001b0m": " to update dependencies\\u001b[0m",
  "addall": " || addAll == ",
  "confirm": " || confirm == ",
  "managepatterns": " || managePatterns == ",
  "response": " || response == ",
  "category": "$category",
  "dayssincelastuseDaysAgo": "$daysSinceLastUse days ago",
  "normalizedpathTryDifferentPossibleLocationsForPubspecYamlFinalListStringPossiblepathsPathJoinRootpath": ")\n        : normalizedPath;\n\n    // Try different possible locations for pubspec.yaml\n    final List<String> possiblePaths = [\n      path.join(rootPath, ",
  "directorypathSubstring0DirectorypathLength1DirectorypathHandleRelativePathsUsingPathPackageForBetterCrossPlatformSupportFinalRootpathNormalizedpathStartswith": ")\n        ? directoryPath.substring(0, directoryPath.length - 1)\n        : directoryPath;\n\n    // Handle relative paths using path package for better cross-platform support\n    final rootPath = normalizedPath.startsWith(",
  "normalizedpathReplacefirst": ")\n        ? normalizedPath.replaceFirst(",
  "prefs": ") &&\n        prefs[",
  "lineEndswith": ") && line.endsWith(",
  "addAllPatternsFromTheCategoryForFinalPatternInCategorypatternsIfPatternsContainsPatternPatternsAddPatternPrefs": ") {\n                  // Add all patterns from the category\n                  for (final pattern in categoryPatterns) {\n                    if (!patterns.contains(pattern)) {\n                      patterns.add(pattern);\n                    }\n                  }\n                  prefs[",
  "hasgenerateTrueBreakIfHasgenerateIfFlutterindex1LinesAdd": ") {\n                hasGenerate = true;\n                break;\n              }\n            }\n          }\n          \n          if (!hasGenerate) {\n            if (flutterIndex == -1) {\n              lines.add(",
  "patternsListStringFromDefaultpreferences": ") {\n            patterns = List<String>.from(\n                _defaultPreferences[",
  "lastsdkdependencyindexI1ElseIfLineStartswith": ") {\n          lastSdkDependencyIndex = i + 1;\n        }\n      } else if (line.startsWith(",
  "promptForNewPreferencesReturnAwaitPromptnewpreferencesPrefsReturnPrefsPromptUserForNewPreferencesStaticFutureMapStringDynamicPromptnewpreferencesMapStringDynamicCurrentprefsAsyncFinalNewprefsMapStringDynamicFromCurrentprefsKeyFormatStdoutWrite": ") {\n      // Prompt for new preferences\n      return await _promptNewPreferences(prefs);\n    }\n\n    return prefs;\n  }\n\n  /// Prompt user for new preferences\n  static Future<Map<String, dynamic>> _promptNewPreferences(\n      Map<String, dynamic> currentPrefs) async {\n    final newPrefs = Map<String, dynamic>.from(currentPrefs);\n\n    // Key format\n    stdout.write(",
  "awaitManageexcludepatternsNewprefsSaveTheNewPreferencesSavepreferencesNewprefsReturnNewprefsManageExcludePatternsInteractivelyStaticFutureVoidManageexcludepatternsMapStringDynamicPrefsAsyncListStringPatternsIfPrefsContainskey": ") {\n      await _manageExcludePatterns(newPrefs);\n    }\n\n    // Save the new preferences\n    savePreferences(newPrefs);\n\n    return newPrefs;\n  }\n\n  /// Manage exclude patterns interactively\n  static Future<void> _manageExcludePatterns(Map<String, dynamic> prefs) async {\n    List<String> patterns = [];\n\n    if (prefs.containsKey(",
  "breakHitAnotherSectionIfLine": ")) break; // Hit another section\n              if (line == ",
  "continueIfLinesIStartswith": ")) continue;\n              if (!lines[i].startsWith(",
  "linesIIntllineBreakElseLinesInsertInsertindexIntllineNeedswriteTruePrint": ")) {\n            lines[i] = intlLine;\n            break;\n          }\n        }\n      } else {\n        lines.insert(insertIndex, intlLine);\n      }\n      needsWrite = true;\n      print(",
  "yamleditorUpdate": ")) {\n            yamlEditor.update([",
  "hasgenerateFluttersection": ")) {\n          hasGenerate = flutterSection[",
  "breakSkipBlankLinesAndCommentsIfLineIsemptyLineStartswith": ")) {\n        break;\n      }\n      \n      // Skip blank lines and comments\n      if (line.isEmpty || line.startsWith(",
  "continueCheckForSpecificDependenciesIfLineStartswith": ")) {\n        continue;\n      }\n\n      // Check for specific dependencies\n      if (line.startsWith(",
  "finalFluttersectionYamldoc": ")) {\n        final flutterSection = yamlDoc[",
  "hasflutterTrueCheckNextLineToVerifyIt": ")) {\n        hasFlutter = true;\n        // Check next line to verify it",
  "hasintlTrueExtractVersionIfPresentFinalVersionmatchRegexpR": ")) {\n        hasIntl = true;\n        // Extract version if present\n        final versionMatch = RegExp(r",
  "print_1": ")) {\n      print(",
  "pubspecupdatedTruePrint": "));\n            pubspecUpdated = true;\n            print(",
  "print_2": "));\n        print(",
  "emptyString_6": "),\n    ",
  "emptyString_7": "),\n      ",
  "pathJoinPathSplitRootpathFirst": "),\n      path.join(path.split(rootPath).first, ",
  "pathJoinPathDirnameDirectorypath": "),\n    path.join(path.dirname(directoryPath), ",
  "emptyString_8": "), ",
  "convertPrefsPrefsfileWriteasstringsyncContentPrint": ").convert(prefs);\n      prefsFile.writeAsStringSync(content);\n      print(",
  "firstmatchContentIfNamematchNullNamematchGroupcount1FinalPkgnameNamematchGroup1Print": ").firstMatch(content);\n      if (nameMatch != null && nameMatch.groupCount >= 1) {\n        final pkgName = nameMatch.group(1)!;\n        print(",
  "firstmatchIntldepIfVersionmatchNullIntlversionVersionmatchGroup1PrintCurrentStatusPrint": ").firstMatch(intlDep);\n        if (versionMatch != null) {\n          intlVersion = versionMatch.group(1);\n        }\n      }\n    }\n\n    // Print current status\n    print(",
  "firstmatchLineIfVersionmatchNullIntlversionVersionmatchGroup1PrintCurrentStatusPrint": ").firstMatch(line);\n        if (versionMatch != null) {\n          intlVersion = versionMatch.group(1);\n        }\n      }\n    }\n\n    // Print current status\n    print(",
  "mapPartExtractOnlyNumericPartInCaseThereAreSuffixesLikeBetaBuildFinalNumericpartRegexpR": ").map((part) {\n      // Extract only numeric part in case there are suffixes like -beta, +build\n      final numericPart = RegExp(r",
  "ifPatternsIsemptyPrint": ");\n\n      if (patterns.isEmpty) {\n        print(",
  "stdoutWrite": ");\n\n      stdout.write(",
  "finalFormatchoiceStdinReadlinesync": ");\n\n    final formatChoice = stdin.readLineSync() ?? ",
  "stdoutWrite_1": ");\n\n    stdout.write(",
  "tryReturnCleanversionSplit": ");\n  \n  try {\n    return cleanVersion.split(",
  "text1FindAndUpdatePubspecYamlToEnsure": ");\n    \n    // 1. Find and update pubspec.yaml to ensure ",
  "checkIntlVersionIfItExistsStringIntlversionIfHasintlFinalIntldepDependencies": ");\n    \n    // Check intl version if it exists\n    String? intlVersion;\n    if (hasIntl) {\n      final intlDep = dependencies[",
  "firstFindTheDependenciesSectionFinalDependenciesindexLinesIndexwhereLineLineTrim": ");\n    \n    // First find the dependencies section\n    final dependenciesIndex = lines.indexWhere((line) => line.trim() == ",
  "finalContentPubspecfileReadasstringsyncParseTheYamlContentToCheckExistingDependenciesFinalYamldocLoadyamlContentCheckIfDependenciesSectionExistsIfYamldocIsMapYamldocContainskey": ");\n    \n    final content = pubspecFile.readAsStringSync();\n    \n    // Parse the YAML content to check existing dependencies\n    final yamlDoc = loadYaml(content);\n    \n    // Check if dependencies section exists\n    if (yamlDoc is! Map || !yamlDoc.containsKey(",
  "verifyTheWriteWasSuccessfulByReadingBackFinalVerifycontentPubspecfileReadasstringsyncFinalHasintlcheckVerifycontentContains": ");\n        \n        // Verify the write was successful by reading back\n        final verifyContent = pubspecFile.readAsStringSync();\n        final hasIntlCheck = verifyContent.contains(",
  "ifHasintlcheckHasflutterloccheckPrint": ");\n        \n        if (hasIntlCheck && hasFlutterLocCheck) {\n          print(",
  "checkIfGenerateTrueAlreadyExistsBoolHasgenerateFalseIfFlutterindex1ForIntIFlutterindex1ILinesLengthIFinalLineLinesITrimIfLineIsemptyLineStartswith": ");\n          \n          // Check if generate: true already exists\n          bool hasGenerate = false;\n          if (flutterIndex != -1) {\n            for (int i = flutterIndex + 1; i < lines.length; i++) {\n              final line = lines[i].trim();\n              if (line.isEmpty || line.startsWith(",
  "print_3": ");\n                      print(\n                          ",
  "elsePrint_2": ");\n                      }\n                    } else {\n                      print(",
  "elsePrint_3": ");\n                      } else {\n                        print(\n                            ",
  "elsePrint_4": ");\n                    }\n                  }\n                }\n              } else {\n                print(",
  "catchEPrint_1": ");\n                    }\n                  } catch (e) {\n                    print(",
  "elsePrint_5": ");\n                    } else {\n                      print(\n                          ",
  "finalPatternstrStdinReadlinesyncIfPatternstrNullPatternstrIsnotemptyFinalPatternindexIntParsePatternstrIfPatternindex1PatternindexCategorypatternsLengthFinalPatternCategorypatternsPatternindex1IfPatternsContainsPatternPatternsAddPatternPrefs": ");\n                  final patternStr = stdin.readLineSync();\n                  if (patternStr != null && patternStr.isNotEmpty) {\n                    final patternIndex = int.parse(patternStr);\n                    if (patternIndex >= 1 &&\n                        patternIndex <= categoryPatterns.length) {\n                      final pattern = categoryPatterns[patternIndex - 1];\n                      if (!patterns.contains(pattern)) {\n                        patterns.add(pattern);\n                        prefs[",
  "finalSampletextStdinReadlinesync": ");\n                  final sampleText = stdin.readLineSync() ?? ",
  "elsePrint_6": ");\n                  }\n                } else {\n                  print(",
  "finalAddallStdinReadlinesyncTolowercase": ");\n                final addAll = stdin.readLineSync()?.toLowerCase() ?? ",
  "forVarI0ICategorypatternsLengthIPrint": ");\n                for (var i = 0; i < categoryPatterns.length; i++) {\n                  print(\n                      ",
  "stdoutWrite_2": ");\n                }\n\n                stdout.write(",
  "catchEPrint_2": ");\n                }\n              } catch (e) {\n                print(",
  "elseAllowSelectingIndividualPatternsStdoutWrite": ");\n                } else {\n                  // Allow selecting individual patterns\n                  stdout.write(\n                      ",
  "elsePrint_7": ");\n                } else {\n                  print(",
  "linesAdd": ");\n              lines.add(",
  "breakCase": ");\n              }\n            }\n          }\n          break;\n\n        case ",
  "catchEPrint_3": ");\n              }\n            } catch (e) {\n              print(",
  "elsePatternsAddNewpatternPrefs": ");\n              } else {\n                patterns.add(newPattern);\n                prefs[",
  "finalIndexstrStdinReadlinesyncIfIndexstrNullIndexstrIsnotemptyTryFinalIndexIntParseIndexstrIfIndex1IndexPatternsLengthFinalPatternPatternsIndex1StdoutWrite": ");\n            final indexStr = stdin.readLineSync();\n            if (indexStr != null && indexStr.isNotEmpty) {\n              try {\n                final index = int.parse(indexStr);\n                if (index >= 1 && index <= patterns.length) {\n                  final pattern = patterns[index - 1];\n                  stdout.write(",
  "finalIndexstrStdinReadlinesyncIfIndexstrNullIndexstrIsnotemptyTryFinalIndexIntParseIndexstrIfIndex1IndexPatternsLengthFinalRemovedpatternPatternsRemoveatIndex1Prefs": ");\n            final indexStr = stdin.readLineSync();\n            if (indexStr != null && indexStr.isNotEmpty) {\n              try {\n                final index = int.parse(indexStr);\n                if (index >= 1 && index <= patterns.length) {\n                  final removedPattern = patterns.removeAt(index - 1);\n                  prefs[",
  "pubspecfileWriteasstringsyncLinesJoin": ");\n            }\n            pubspecFile.writeAsStringSync(lines.join(",
  "breakCase_1": ");\n            }\n          }\n          break;\n\n        case ",
  "elseLinesInsertFlutterindex1": ");\n            } else {\n              lines.insert(flutterIndex + 1, ",
  "finalCategoriesPatterncategoriesKeysTolistForVarI0ICategoriesLengthIPrint": ");\n          final categories = patternCategories.keys.toList();\n          for (var i = 0; i < categories.length; i++) {\n            print(",
  "finalCategorystrStdinReadlinesyncIfCategorystrNullCategorystrIsnotemptyTryFinalIndexIntParseCategorystrIfIndex1IndexCategoriesLengthFinalCategoryCategoriesIndex1FinalCategorypatternsPatterncategoriesCategoryPrint": ");\n          final categoryStr = stdin.readLineSync();\n          if (categoryStr != null && categoryStr.isNotEmpty) {\n            try {\n              final index = int.parse(categoryStr);\n              if (index >= 1 && index <= categories.length) {\n                final category = categories[index - 1];\n                final categoryPatterns = patternCategories[category]!;\n\n                print(",
  "finalConfirmStdinReadlinesyncTolowercase": ");\n          final confirm = stdin.readLineSync()?.toLowerCase() ?? ",
  "finalNewpatternStdinReadlinesyncIfNewpatternNullNewpatternIsnotemptyTryRegexpNewpatternCheckIfPatternAlreadyExistsIfPatternsContainsNewpatternPrint": ");\n          final newPattern = stdin.readLineSync();\n          if (newPattern != null && newPattern.isNotEmpty) {\n            try {\n              RegExp(newPattern);\n\n              // Check if pattern already exists\n              if (patterns.contains(newPattern)) {\n                print(\n                    ",
  "intFlutterindexLinesIndexwhereLineLineTrim": ");\n          int flutterIndex = lines.indexWhere((line) => line.trim() == ",
  "print_4": ");\n          print(",
  "stdoutWrite_3": ");\n          }\n\n          stdout.write(",
  "breakCase_2": ");\n          }\n          break;\n\n        case ",
  "elsePrint_8": ");\n          }\n        }\n      } else {\n        print(",
  "elsePrint_9": ");\n          } else {\n            print(",
  "elseStdoutWrite": ");\n          } else {\n            stdout.write(\n                ",
  "finalHasflutterloccheckVerifycontentContains": ");\n        final hasFlutterLocCheck = verifyContent.contains(",
  "ifPubspecExistssyncPubspecfilePubspecBreakCurrentdirCurrentdirParentIfPubspecfileNullFinalContentPubspecfileReadasstringsyncTryToFindThePackageNameWithAMoreRobustRegexFinalNamematchRegexpR": ");\n        if (pubspec.existsSync()) {\n          pubspecFile = pubspec;\n          break;\n        }\n        currentDir = currentDir.parent;\n      }\n    }\n\n    if (pubspecFile != null) {\n      final content = pubspecFile.readAsStringSync();\n      \n      // Try to find the package name with a more robust regex\n      final nameMatch = RegExp(r",
  "print_5": ");\n        print(",
  "returnFalseElsePrint": ");\n        return false;\n      }\n    } else {\n      print(",
  "returnPkgnamePrint": ");\n        return pkgName;\n      }\n\n      print(",
  "print_6": ");\n        }\n      }\n\n      print(",
  "catchWriteerrorPrint": ");\n        }\n      } catch (writeError) {\n        print(",
  "elsePrint_10": ");\n        } else {\n          print(",
  "finalOptionStdinReadlinesync": ");\n      final option = stdin.readLineSync() ?? ",
  "insertindexLinesInsertInsertindex": ");\n      insertIndex++;\n      lines.insert(insertIndex, ",
  "lastsdkdependencyindexInsertindexNeedswriteTruePrint": ");\n      lastSdkDependencyIndex = insertIndex;\n      needsWrite = true;\n      print(",
  "needsintlupdateCompareversionsCurrentversionMinversion0IfNeedsintlupdateInsertindexLastsdkdependencyindex1FinalIntlline": ");\n      needsIntlUpdate = _compareVersions(currentVersion, minVersion) < 0;\n    }\n    \n    if (needsIntlUpdate) {\n      insertIndex = lastSdkDependencyIndex + 1;\n      final intlLine = ",
  "print_7": ");\n      print(",
  "returnFalseAnalyzeExistingDependenciesScanTheEntireDependenciesSectionBoolHasflutterFalseBoolHasflutterlocalizationsFalseBoolHasintlFalseIntLastsdkdependencyindexDependenciesindexStringIntlversionGoThroughEachLineAfterDependenciesToFindExistingDepsForVarIDependenciesindex1ILinesLengthIFinalLineLinesITrimStopIfWeHitAnotherTopLevelSectionNoLeadingSpacesAndEndsWithColonIfLineIsnotemptyLinesIStartswith": ");\n      return false;\n    }\n\n    // Analyze existing dependencies - scan the entire dependencies section\n    bool hasFlutter = false;\n    bool hasFlutterLocalizations = false;\n    bool hasIntl = false;\n    int lastSdkDependencyIndex = dependenciesIndex;\n    String? intlVersion;\n\n    // Go through each line after dependencies to find existing deps\n    for (var i = dependenciesIndex + 1; i < lines.length; i++) {\n      final line = lines[i].trim();\n      \n      // Stop if we hit another top-level section (no leading spaces and ends with colon)\n      if (line.isNotEmpty && !lines[i].startsWith(",
  "returnFalseBoolPubspecupdatedFalseTryFinalContentPubspecfileReadasstringsyncFinalYamleditorYamleditorContentCheckIfFlutterGenerateIsAlreadySetToTrueFinalYamldocLoadyamlContentBoolHasgenerateFalseIfYamldocIsMapYamldocContainskey": ");\n      return false;\n    }\n\n    bool pubspecUpdated = false;\n    try {\n      final content = pubspecFile.readAsStringSync();\n      final yamlEditor = YamlEditor(content);\n      \n      // Check if flutter.generate is already set to true\n      final yamlDoc = loadYaml(content);\n      bool hasGenerate = false;\n      \n      if (yamlDoc is Map && yamlDoc.containsKey(",
  "returnFalseFinalDependenciesYamldoc": ");\n      return false;\n    }\n\n    final dependencies = yamlDoc[",
  "returnFalsePrint": ");\n      return false;\n    }\n\n    print(",
  "catchEPrint_4": ");\n      }\n    } catch (e) {\n      print(",
  "elsePrint_11": ");\n      }\n    } else {\n      print(",
  "catchEPrint_5": ");\n      } catch (e) {\n        print(",
  "elseForVarI0IPatternsLengthIPrint": ");\n      } else {\n        for (var i = 0; i < patterns.length; i++) {\n          print(",
  "finalHasflutterlocalizationsDependenciesContainskey": ");\n    final hasFlutterLocalizations = dependencies.containsKey(",
  "finalHasintlDependenciesContainskey": ");\n    final hasIntl = dependencies.containsKey(",
  "finalManagepatternsStdinReadlinesyncTolowercase": ");\n    final managePatterns = stdin.readLineSync()?.toLowerCase() ?? ",
  "finalOutdirStdinReadlinesyncIfOutdirNullOutdirIsnotemptyNewprefs": ");\n    final outDir = stdin.readLineSync();\n    if (outDir != null && outDir.isNotEmpty) {\n      newPrefs[",
  "finalResponseStdinReadlinesyncTolowercase": ");\n    final response = stdin.readLineSync()?.toLowerCase() ?? ",
  "ifDependenciesindex1Print": ");\n    if (dependenciesIndex == -1) {\n      print(",
  "print_8": ");\n    print(",
  "return": ");\n    return ",
  "returnFalseEnhancedVersionUsingYamlEditForSaferYamlManipulationChecksIfFlutterLocalizationsAndIntlDependenciesExistInPubspecYamlIfNotAddsThemAutomaticallyUsingStructuredYamlEditingBoolEnsureflutterlocalizationsdependencysafeStringDirectorypathTryFindPubspecYamlFileUsingTheExistingFunctionFinalPubspecfileFindpubspecfileDirectorypathIfPubspecfileNullPrint": ");\n    return false;\n  }\n}\n\n/// Enhanced version using yaml_edit for safer YAML manipulation\n/// Checks if flutter_localizations and intl dependencies exist in pubspec.yaml\n/// If not, adds them automatically using structured YAML editing\nbool ensureFlutterLocalizationsDependencySafe(String directoryPath) {\n  try {\n    // Find pubspec.yaml file using the existing function\n    final pubspecFile = _findPubspecFile(directoryPath);\n\n    if (pubspecFile == null) {\n      print(",
  "returnSanitizeddirnameCatchEPrint": ");\n    return sanitizedDirName;\n  } catch (e) {\n    print(",
  "stdoutWrite_4": ");\n    stdout.write(",
  "text2CreateL10nYamlConfigurationFileIfItDoesn": ");\n    }\n\n    // 2. Create l10n.yaml configuration file if it doesn",
  "text3EnsureLibL10nDirectoryExistsFinalL10ndirDirectoryPathJoinProjectroot": ");\n    }\n\n    // 3. Ensure lib/l10n directory exists\n    final l10nDir = Directory(path.join(projectRoot, ",
  "handleFlutterLocalizationsIfMissingIfHasflutterlocalizationsInsertindexLastsdkdependencyindex1LinesInsertInsertindex": ");\n    }\n\n    // Handle flutter_localizations if missing\n    if (!hasFlutterLocalizations) {\n      insertIndex = lastSdkDependencyIndex + 1;\n      lines.insert(insertIndex, ",
  "handleIntlIfMissingOrNeedsVersionUpdateCompareVersionNumbersProperlyNeedAtLeast0180BoolNeedsintlupdateHasintlIfHasintlIntlversionNullParseVersionNumbersForProperComparisonFinalCurrentversionParseversionIntlversionFinalMinversionParseversion": ");\n    }\n\n    // Handle intl if missing or needs version update\n    // Compare version numbers properly - need at least 0.18.0\n    bool needsIntlUpdate = !hasIntl;\n    if (hasIntl && intlVersion != null) {\n      // Parse version numbers for proper comparison\n      final currentVersion = _parseVersion(intlVersion);\n      final minVersion = _parseVersion(",
  "useDirectoryNameAsFallbackFinalDirnamePathBasenamePathDirnamePubspecfilePathDirectorypathFinalSanitizeddirnameDirnameReplaceallRegexpR": ");\n    }\n\n    // Use directory name as fallback\n    final dirName = path.basename(path.dirname(pubspecFile?.path ?? directoryPath));\n    final sanitizedDirName = dirName.replaceAll(RegExp(r",
  "ifNeedswriteWriteChangesBackToFileTryPubspecfileWriteasstringsyncLinesJoin": ");\n    }\n\n    if (needsWrite) {\n      // Write changes back to file\n      try {\n        pubspecFile.writeAsStringSync(lines.join(",
  "returnTrueCatchEPrint": ");\n    }\n    \n    return true;\n  } catch (e) {\n    print(",
  "askUserIfTheyWantToUseSavedPreferencesOrChangeThemStaticFutureMapStringDynamicPromptforpreferencesAsyncFinalPrefsLoadpreferencesFinalLastuseddateDatetimeParsePrefs": {
    "male": ");\n    }\n  }\n\n  /// Ask user if he want to use saved preferences or change them\n  static Future<Map<String, dynamic>> promptForPreferences() async {\n    final prefs = loadPreferences();\n    final lastUsedDate = DateTime.parse(prefs[",
    "female": ");\n    }\n  }\n\n  /// Ask user if she want to use saved preferences or change them\n  static Future<Map<String, dynamic>> promptForPreferences() async {\n    final prefs = loadPreferences();\n    final lastUsedDate = DateTime.parse(prefs[",
    "other": ");\n    }\n  }\n\n  /// Ask user if they want to use saved preferences or change them\n  static Future<Map<String, dynamic>> promptForPreferences() async {\n    final prefs = loadPreferences();\n    final lastUsedDate = DateTime.parse(prefs["
  },
  "catchEPrint_6": ");\n    } catch (e) {\n      print(",
  "emptyString_9": ",\n    ",
  "pathJoin": ",\n      path.join(",
  "forFinalPossiblepathInPossiblepathsFinalFileFilePossiblepathIfFileExistssyncReturnFileIfWeStillHaven": ",\n  ];\n\n  for (final possiblePath in possiblePaths) {\n    final file = File(possiblePath);\n    if (file.existsSync()) {\n      return file;\n    }\n  }\n\n  // If we still haven",
  "annotationsR": ", // Annotations\n        r",
  "assetPathsR": ", // Asset paths\n        r",
  "classReferencesLikeWidgetPropertyR": ", // Class references like Widget.property\n        r",
  "colorHexCodes": ", // Color hex codes\n      ],\n      ",
  "imageAndDataFilesR": ", // Image and data files\n        r",
  "numbersAndSimpleFormattedNumbersR": ", // Numbers and simple formatted numbers\n        r",
  "privateVariablesWhileTruePrint": ", // Private variables\n      ],\n    };\n\n    while (true) {\n      print(",
  "simpleFileExtensions": ", // Simple file extensions\n      ],\n      ",
  "simpleFilePathsWithNoSpacesR": ", // Simple file paths with no spaces\n        r",
  "uriSchemes": ", // URI schemes\n      ],\n      ",
  "urlsWithHttpHttpsR": ", // URLs with http/https\n        r",
  "uuids": ", // UUIDs\n      ],\n      ",
  "versionNumbersR": ", // Version numbers\n        r",
  "webAddressesStartingWithWwwR": ", // Web addresses starting with www\n        r",
  "xmlHtmlTagsR": ", // XML/HTML tags\n        r",
  "intlCliPrefsJson": ".intl_cli_prefs.json",
  "text0180": "0.18.0",
  "showCategoryOptionsPrint": ":\n          // Show category options\n          print(",
  "testPatternAgainstSampleTextIfPatternsIsemptyPrint": ":\n          // Test pattern against sample text\n          if (patterns.isEmpty) {\n            print(",
  "ifPatternsIsemptyPrint_1": ":\n          if (patterns.isEmpty) {\n            print(",
  "stdoutWrite_5": ":\n          stdout.write(",
  "defaultReturnExitTheManagementLoopHelperFunctionToDetectPackageNameFromPubspecYamlStringDetectpackagenameStringDirectorypathTryNormalizePathToMakeSureItDoesn": ":\n        default:\n          return; // Exit the management loop\n      }\n    }\n  }\n}\n\n// Helper function to detect package name from pubspec.yaml\nString detectPackageName(String directoryPath) {\n  try {\n    // Normalize path to make sure it doesn",
  "newprefs": ":\n        newPrefs[",
  "r_1": ": [\n        r",
  "tryFinalRegexRegexpPatternFinalMatchesRegexHasmatchSampletextIfMatchesPrint": ";\n\n                  try {\n                    final regex = RegExp(pattern);\n                    final matches = regex.hasMatch(sampleText);\n\n                    if (matches) {\n                      print(\n                          ",
  "ifAddall": ";\n\n                if (addAll == ",
  "switchOptionCase": ";\n\n      switch (option) {\n        case ",
  "ifManagepatterns": ";\n\n    if (managePatterns == ",
  "ifResponse": ";\n\n    if (response == ",
  "ifConfirm": ";\n          if (confirm == ",
  "breakCase_3": ";\n        break;\n      case ",
  "breakDefaultNewprefs": ";\n        break;\n      default:\n        newPrefs[",
  "l10nfileWriteasstringsyncL10nconfigL10ncreatedTruePrint": ";\n        l10nFile.writeAsStringSync(l10nConfig);\n        l10nCreated = true;\n        print(",
  "ifHasintlReplaceExistingIntlLineForVarI0ILinesLengthIIfLinesITrimStartswith": ";\n      if (hasIntl) {\n        // Replace existing intl line\n        for (var i = 0; i < lines.length; i++) {\n          if (lines[i].trim().startsWith(",
  "finalSdkindentation": ";\n    final sdkIndentation = ",
  "switchFormatchoiceCase": ";\n    switch (formatChoice) {\n      case ",
  "varInsertindexLastsdkdependencyindexHandleFlutterSdkIfMissingIfHasflutterInsertindexLinesInsertInsertindex": ";\n    var insertIndex = lastSdkDependencyIndex;\n\n    // Handle Flutter SDK if missing\n    if (!hasFlutter) {\n      insertIndex++;\n      lines.insert(insertIndex, ",
  "outputDirectoryStdoutWrite": ";\n    }\n\n    // Output directory\n    stdout.write(",
  "helperFunctionToFindPubspecYamlFileInVariousPossibleLocationsFileFindpubspecfileStringDirectorypathFinalPossiblepathsPathJoinDirectorypath": ";\n  }\n}\n\n/// Helper function to find pubspec.yaml file in various possible locations\nFile? _findPubspecFile(String directoryPath) {\n  final possiblePaths = [\n    path.join(directoryPath, ",
  "added": "Added",
  "couldNotDetermineHomeDirectory": "Could not determine home directory",
  "home": "HOME",
  "userprofile": "USERPROFILE",
  "updated": "Updated",
  "rMessage": "\\r$message",
  "u001b31merrorAddingDependenciesWithYamlEditorEU001b0m": "\\u001b[31mError adding dependencies with YAML editor: $e\\u001b[0m",
  "u001b31merrorSettingUpFlutterLocalizationConfigurationEU001b0m": "\\u001b[31mError setting up Flutter localization configuration: $e\\u001b[0m",
  "u001b31merrorWritingToPubspecYamlWithYamlEditorWriteerrorU001b0m": "\\u001b[31mError writing to pubspec.yaml with YAML editor: $writeError\\u001b[0m",
  "u001b31merrorCouldNotFindPubspecYamlFileU001b0m": "\\u001b[31mError: Could not find pubspec.yaml file\\u001b[0m",
  "u001b32mHasintl": "\\u001b[32m✓ ${hasIntl ? ",
  "u001b32mAdded": "\\u001b[32m✓ Added ",
  "u001b32mAddedFlutterSdkDependencyU001b0m": "\\u001b[32m✓ Added flutter SDK dependency\\u001b[0m",
  "u001b32mAddedFlutterLocalizationsDependencyU001b0m": "\\u001b[32m✓ Added flutter_localizations dependency\\u001b[0m",
  "u001b32mAllRequiredDependenciesAreAlreadyPresentU001b0m": "\\u001b[32m✓ All required dependencies are already present\\u001b[0m",
  "u001b32mCreatedLibL10nDirectoryU001b0m": "\\u001b[32m✓ Created lib/l10n directory\\u001b[0m",
  "u001b32mDependenciesUpdatedSuccessfullyUsingYamlEditorInPubspecfilePathU001b0m": "\\u001b[32m✓ Dependencies updated successfully using YAML editor in ${pubspecFile.path}\\u001b[0m",
  "u001b32mFlutterLocalizationConfigurationSetupCompletedU001b0m": "\\u001b[32m✓ Flutter localization configuration setup completed\\u001b[0m",
  "u001b32mVerifiedDependenciesSuccessfullyWrittenToFileU001b0m": "\\u001b[32m✓ Verified: Dependencies successfully written to file\\u001b[0m",
  "u001b33mIntlFoundHasintlcheckFlutterLocalizationsFoundHasflutterloccheckU001b0m": "\\u001b[33m   intl found: $hasIntlCheck, flutter_localizations found: $hasFlutterLocCheck\\u001b[0m",
  "u001b33mdirectoryDirectorypathU001b0m": "\\u001b[33mDirectory: $directoryPath\\u001b[0m",
  "u001b33mfilePathPubspecfilePathU001b0m": "\\u001b[33mFile path: ${pubspecFile.path}\\u001b[0m",
  "u001b33msearchedInDirectoryDirectorypathU001b0m": "\\u001b[33mSearched in directory: $directoryPath\\u001b[0m",
  "u001b33mwarningFailedToLoadPreferencesEU001b0m": "\\u001b[33mWarning: Failed to load preferences: $e\\u001b[0m",
  "u001b33mCouldNotCreateLibL10nDirectoryEU001b0m": "\\u001b[33m⚠️  Could not create lib/l10n directory: $e\\u001b[0m",
  "u001b33mWarningDependenciesMayNotHaveBeenWrittenCorrectlyU001b0m": "\\u001b[33m⚠️  Warning: Dependencies may not have been written correctly\\u001b[0m",
  "u001b33mYamlEditorFailedTryingStringBasedApproachU001b0m": "\\u001b[33m⚠️  YAML editor failed, trying string-based approach...\\u001b[0m",
  "u001b36mFlutterLocalizationsHasflutterlocalizations": "\\u001b[36m  flutter_localizations: ${hasFlutterLocalizations ? ",
  "u001b36mIntlHasintl": "\\u001b[36m  intl: ${hasIntl ? ",
  "u001b36mFallingBackToStringBasedMethodU001b0m": "\\u001b[36mℹ️  Falling back to string-based method...\\u001b[0m",
  "u001b36mFlutterLocalizationConfigurationAlreadyProperlySetUpU001b0m": "\\u001b[36mℹ️  Flutter localization configuration already properly set up\\u001b[0m",
  "u001b36mFoundPubspecYamlAtPubspecfilePathU001b0m": "\\u001b[36mℹ️  Found pubspec.yaml at: ${pubspecFile.path}\\u001b[0m",
  "u001b36mRun": "\\u001b[36mℹ️  Run ",
  "u001b36mLibL10nDirectoryAlreadyExistsU001b0m": "\\u001b[36mℹ️  lib/l10n directory already exists\\u001b[0m",
  "emptyString_10": "] = ",
  "outdirAskIfUserWantsToManageExcludePatternsStdoutWrite": "] = outDir;\n    }\n\n    // Ask if user wants to manage exclude patterns\n    stdout.write(",
  "patternsPrint": "] = patterns;\n                        print(",
  "patternsPrint_1": "] = patterns;\n                  print(",
  "patternsPrint_2": "] = patterns;\n                  print(\n                      ",
  "patternsPrint_3": "] = patterns;\n                print(",
  "patternsPrint_4": "] = patterns;\n            print(",
  "trueIfHasgenerateFirstEnsureFlutterSectionExistsTryIfYamldocIsMapYamldocContainskey": "] == true;\n        }\n      }\n      \n      if (!hasGenerate) {\n        // First ensure flutter section exists\n        try {\n          if (yamlDoc is! Map || !yamlDoc.containsKey(",
  "asListCastStringListOfCommonPatternCategoriesToOfferToTheUserFinalPatterncategories": "] as List).cast<String>();\n    }\n\n    // List of common pattern categories to offer to the user\n    final patternCategories = {\n      ",
  "asListPrefs": "] as List);\n            prefs[",
  "asMapDynamicDynamicCheckExistingDependenciesFinalHasflutterDependenciesContainskey": "] as Map<dynamic, dynamic>;\n\n    // Check existing dependencies\n    final hasFlutter = dependencies.containsKey(",
  "isListPatternsPrefs": "] is List) {\n      patterns = (prefs[",
  "finalDayssincelastuseDatetimeNowDifferenceLastuseddateIndaysPrint": "]);\n    final daysSinceLastUse = DateTime.now().difference(lastUsedDate).inDays;\n\n    print(\n        ",
  "thenAddUpdateFlutterGenerateToTrueYamleditorUpdate": "], {});\n          }\n          // Then add/update flutter.generate to true\n          yamlEditor.update([",
  "ifFluttersectionIsMapFluttersectionContainskey": "];\n        if (flutterSection is Map && flutterSection.containsKey(",
  "ifIntldepIsStringFinalVersionmatchRegexpR": "];\n      if (intlDep is String) {\n        final versionMatch = RegExp(r",
  "text09aFaF38": "^#[0-9a-fA-F]{3,8}$",
  "text0190": "^0.19.0",
  "emptyString_11": "^<[^>]+>$",
  "emptyString_12": "^[\\^~>=<]+",
  "d": "^[\\d,.]+$",
  "wPngJpgJpegSvgGifWebpJsonArbMd": "^[\\w-]+\\.(?:png|jpg|jpeg|svg|gif|webp|json|arb|md)$",
  "w": "^[\\w/\\-\\.]+$",
  "wW": "^\\w+://\\w+",
  "w_1": "^\\w+\\.",
  "assets": "^assets/",
  "https": "^https?://",
  "www": "^www\\.",
  "dartConvert_1": "dart:convert",
  "dartIo_2": "dart:io",
  "flutterPubGet": "flutter pub get",
  "flutterLocalizations": "flutter_localizations:",
  "generateTrue": "generate: true",
  "intl": "intl:",
  "l10nYaml": "l10n.yaml",
  "libL10n": "lib/l10n",
  "pubspecYaml": "pubspec.yaml",
  "sAnSdkDependencyIfI1LinesLengthLinesI1Trim": "s an SDK dependency\n        if (i + 1 < lines.length && lines[i + 1].trim() == ",
  "sLocalizationGenerationBoolSetupflutterlocalizationconfigurationStringProjectrootTryPrint": "s localization generation\nbool setupFlutterLocalizationConfiguration(String projectRoot) {\n  try {\n    print(",
  "sdkFlutter": "sdk: flutter",
  "tFoundItTrySearchingUpTheDirectoryTreeVarCurrentdirDirectoryRootpathWhileCurrentdirPath": "t found it, try searching up the directory tree\n      var currentDir = Directory(rootPath);\n      while (currentDir.path != ",
  "intlDependencyToV0190U001b0m": "} intl dependency to v0.19.0\\u001b[0m",
  "intlversionNull": "}${intlVersion != null ? ",
  "u001b0m": "}\\u001b[0m",
  "join": ")\n                    .join(",
  "trimReplaceallRegexpR": ")\n        .trim()\n        .replaceAll(RegExp(r",
  "emptyString_13": "), ",
  "hasmatchKeyReturnFalseCanOnlyContainLettersNumbersAndUnderscoresIfRegexpR": ").hasMatch(key)) return false;\n    \n    // Can only contain letters, numbers, and underscores\n    if (!RegExp(r",
  "hasmatchKeyReturnFalseReturnTrueGenerateAUniqueKeyByAddingASuffixIfNeededStaticStringMakekeyuniqueStringBasekeySetStringExistingkeysVarKeyBasekeyIntSuffix1WhileExistingkeysContainsKeyKey": ").hasMatch(key)) return false;\n    \n    return true;\n  }\n\n  /// Generate a unique key by adding a suffix if needed\n  static String makeKeyUnique(String baseKey, Set<String> existingKeys) {\n    var key = baseKey;\n    int suffix = 1;\n    \n    while (existingKeys.contains(key)) {\n      key = ",
  "handleEmptyInputIfBaseIsemptyReturn": ");\n\n    // Handle empty input\n    if (base.isEmpty) return ",
  "ensureFirstWordDoesn": ");\n    \n    // Ensure first word doesn",
  "case": ");\n      \n      case ",
  "checksIfAKeyIsValidForUseInArbFilesAndAsADartMethodNameStaticBoolIsvalidkeyStringKeyMustStartWithALetterOrUnderscoreIfRegexpR": ");\n    }\n  }\n\n  /// Checks if a key is valid for use in ARB files and as a Dart method name\n  static bool isValidKey(String key) {\n    // Must start with a letter or underscore\n    if (!RegExp(r",
  "convertToDotCaseWithoutTruncationReturnWordsJoin": ":\n        // Convert to dot.case without truncation\n        return words.join(",
  "defaultConvertToCamelcaseWithoutTruncationIfWordsIsemptyReturn": ":\n      default:\n        // Convert to camelCase without truncation\n        if (words.isEmpty) return ",
  "varWordsBaseSplit": ";\n\n    var words = base.split(",
  "returnWords0WordsSkip1MapWordWordIsnotemptyWord0TouppercaseWordSubstring1": ";\n        \n        return words[0] + \n               words.skip(1)\n                    .map((word) => word.isNotEmpty \n                        ? word[0].toUpperCase() + word.substring(1) \n                        : ",
  "aZ09S": "[^a-z0-9\\s]",
  "d_1": "^\\d",
  "textWords0": "text${words[0]}",
  "join_1": ")\n                    .join(",
  "hasmatchThisMakesTheKeyUniqueByAddingASuffixIfNeededStringMakekeyuniqueSetStringExistingkeysVarKeyThisVarSuffix1WhileExistingkeysContainsKeyKey": ").hasMatch(this);\n  }\n\n  /// Makes the key unique by adding a suffix if needed\n  String makeKeyUnique(Set<String> existingKeys) {\n    var key = this;\n    var suffix = 1;\n    \n    while (existingKeys.contains(key)) {\n      key = ",
  "hasmatchWords0Words0": ").hasMatch(words[0])) {\n      words[0] = ",
  "case_1": ");\n      \n      case ",
  "checksIfTheStringWouldMakeAValidKeyBoolIsvalidkeyReturnRegexpR": ");\n    }\n  }\n\n  /// Checks if the string would make a valid key\n  bool isValidKey() {\n    return RegExp(r",
  "convertToDotCaseKeepingFullStringReturnWordsJoin": ":\n        // Convert to dot.case keeping full string\n        return words.join(",
  "convertToSnakeCaseKeepingFullStringReturnWordsJoin": ":\n        // Convert to snake_case keeping full string\n        return words.join(",
  "defaultConvertToCamelcaseKeepingFullStringAndPreservingAllWordsReturnWords0WordsSkip1MapWordWordIsnotemptyWord0TouppercaseWordSubstring1": ":\n      default:\n        // Convert to camelCase keeping full string and preserving all words\n        return words[0] + \n               words.skip(1)\n                    .map((word) => word.isNotEmpty \n                        ? word[0].toUpperCase() + word.substring(1) \n                        : ",
  "switchFormatCase": ";\n    }\n\n    switch (format) {\n      case ",
  "aZaZ09": "[a-zA-Z0-9]+",
  "tStartWithANumberIfWords0IsnotemptyRegexpR": "t start with a number\n    if (words[0].isNotEmpty && RegExp(r",
  "intlCliCleanCleanArbFilesOfInvalidIcuSyntax": "  intl_cli clean                     # Clean ARB files of invalid ICU syntax",
  "intlCliI18nDirShortAliasForInternationalize": "  intl_cli i18n [dir]                # Short alias for internationalize",
  "intlCliInternationalizeDirCompleteI18nWorkflow": "  intl_cli internationalize [dir]    # Complete i18n workflow",
  "intlCliScanDirectoryScanForHardcodedStrings": "  intl_cli scan [directory]          # Scan for hardcoded strings",
  "folder": " folder.",
  "print_9": ");\n      print(\n          ",
  "printErrorUsageExit64ExitCode64IndicatesCommandLineUsageErrorElseHandleOtherErrorsWithAHelpfulMessagePrint": ");\n      print(error.usage);\n      exit(64); // Exit code 64 indicates command line usage error\n    } else {\n      // Handle other errors with a helpful message\n      print(",
  "cliRunnerReceivedArgumentsArguments": "CLI runner received arguments: $arguments",
  "cliToolForFlutterInternationalizationManagement": "CLI tool for Flutter internationalization management",
  "ifNoDirectoryIsSpecifiedDefaultsTo": "If no directory is specified, defaults to ",
  "itCanScanForHardcodedStringsGenerateArbFilesAndRefactorYourCodeN": "It can scan for hardcoded strings, generate ARB files, and refactor your code.\\n",
  "quickStart": "Quick start:",
  "thisToolHelpsYouManageInternationalizationInYourFlutterProjects": "This tool helps you manage internationalization in your Flutter projects.",
  "navailableCommands": "\\nAvailable commands:",
  "nrunASpecificCommandWithHelpForMoreInformation": "\\nRun a specific command with --help for more information.",
  "nIntlCliFlutterInternationalizationCliN": "\\n🌍 intl_cli - Flutter Internationalization CLI 🌍\\n",
  "arbGeneratorDart": "arb_generator.dart",
  "commandsCleanCommandDart": "commands/clean_command.dart",
  "commandsGenerateCommandDart": "commands/generate_command.dart",
  "commandsPreferencesCommandDart": "commands/preferences_command.dart",
  "commandsProcessAllCommandDart": "commands/process_all_command.dart",
  "commandsRefactorCommandDart": "commands/refactor_command.dart",
  "commandsScanCommandDart": "commands/scan_command.dart",
  "dartIo_3": "dart:io",
  "utilitiesDart": "utilities.dart",
  "emptyString_14": "\n            ],\n            ",
  "ifNoDirectorySpecifiedDir": " if no directory specified\n      dir = ",
  "dir": "$dir",
  "finalPatternsPrefs": ")) {\n        final patterns = prefs[",
  "groupPatternsByTypeForBetterReadabilityFinalPatterntypes": ");\n\n          // Group patterns by type for better readability\n          final patternTypes = {\n            ",
  "forVarI0ITypepatternsLengthIPrint": ");\n              for (var i = 0; i < typePatterns.length; i++) {\n                print(",
  "print_10": ");\n              }\n            }\n          }\n\n          print(",
  "forVarI0IStringsLengthIPrint": ");\n          for (var i = 0; i < strings.length; i++) {\n            print(",
  "print_11": ");\n          print(",
  "print_12": ");\n          print(\n              ",
  "elseForFinalFileInExtractedstringsKeysFinalShortpathFileReplaceallNonnulldir": ");\n          }\n        });\n      } else {\n        for (final file in extractedStrings.keys) {\n          final shortPath = file.replaceAll(nonNullDir, ",
  "returnIntTotalstrings0ExtractedstringsForeachFileStringsTotalstringsStringsLengthCreateANonNullVariableForStringOperationsFinalNonnulldirDirPrint": ");\n        return;\n      }\n      int totalStrings = 0;\n      extractedStrings\n          .forEach((file, strings) => totalStrings += strings.length);\n\n      // Create a non-null variable for string operations\n      final nonNullDir = dir;\n\n      print(\n          ",
  "tryFinalExtractedstringsAwaitIntlCliScandirectoryDirExcludepatternsExcludepatternsIfExtractedstringsIsemptyPrint": ");\n        }\n      }\n    }\n    try {\n      final extractedStrings =\n          await intl_cli.scanDirectory(dir, excludePatterns: excludePatterns);\n      if (extractedStrings.isEmpty) {\n        print(",
  "onFilesystemexceptionCatchEStderrWriteln": ");\n        }\n      }\n    } on FileSystemException catch (e) {\n      stderr\n          .writeln(",
  "exit1FinalVerboseArgresults": ");\n      exit(1);\n    }\n\n    final verbose = argResults![",
  "exit2CatchEStderrWriteln": ");\n      exit(2);\n    } catch (e) {\n      stderr.writeln(",
  "ifVerboseExtractedstringsForeachFileStringsFinalShortpathFileReplaceallNonnulldir": ");\n      if (verbose) {\n        extractedStrings.forEach((file, strings) {\n          final shortPath = file.replaceAll(nonNullDir, ",
  "stderrWriteln": ");\n      stderr.writeln(",
  "argparserAddflag": ");\n    argParser.addFlag(",
  "validateDirectoryExistsIfDirectoryDirExistssyncPrint": ");\n    }\n\n    // Validate directory exists\n    if (!Directory(dir).existsSync()) {\n      print(",
  "overrideVoidRunAsyncDetermineTheDirectoryToScanCheckPositionalArgsFirstThenDirFlagVarDirArgresultsRestIsnotemptyArgresultsRestFirstArgresults": ");\n  }\n\n  @override\n  void run() async {\n    // Determine the directory to scan - check positional args first, then --dir flag\n    var dir = argResults!.rest.isNotEmpty\n        ? argResults!.rest.first\n        : argResults![",
  "r_2": ",\n              r",
  "abbr": ",\n        abbr: ",
  "defaultstoTrueHelp": ",\n        defaultsTo: true,\n        help: ",
  "help": ",\n        help: ",
  "help_1": ", help: ",
  "r_3": ", r",
  "cliRunnerDart": "../cli_runner.dart",
  "r_4": ": [\n              r",
  "categorizePatternsFinalCategorizedpatternsStringListStringForFinalKeyInPatterntypesKeysCategorizedpatternsKeyForFinalPatternInExcludepatternsBoolFoundFalseForFinalTypeInPatterntypesKeysIfPatterntypesTypeContainsPatternCategorizedpatternsTypeAddPatternFoundTrueBreakIfFoundCategorizedpatterns": ": [],\n          };\n\n          // Categorize patterns\n          final categorizedPatterns = <String, List<String>>{};\n          for (final key in patternTypes.keys) {\n            categorizedPatterns[key] = [];\n          }\n\n          for (final pattern in excludePatterns) {\n            bool found = false;\n            for (final type in patternTypes.keys) {\n              if (patternTypes[type]!.contains(pattern)) {\n                categorizedPatterns[type]!.add(pattern);\n                found = true;\n                break;\n              }\n            }\n            if (!found) {\n              categorizedPatterns[",
  "r_5": ": [r",
  "print_13": ";\n      print(",
  "scanProjectForHardcodedStringsThatCanBeInternationalized": "Scan project for hardcoded strings that can be internationalized",
  "u001b33mStringsIU001b0m": "\\u001b[33m${strings[i]}\\u001b[0m",
  "asStringIfDirNullDirIsemptyDefaultTo": "] as String?;\n\n    if (dir == null || dir.isEmpty) {\n      // Default to ",
  "asBoolListStringExcludepatternsUseSavedPreferencesIfRequestedIfUseprefsFinalPrefsAwaitPreferencesmanagerPromptforpreferencesIfPrefsContainskey": "] as bool;\n\n    List<String>? excludePatterns;\n\n    // Use saved preferences if requested\n    if (usePrefs) {\n      final prefs = await PreferencesManager.promptForPreferences();\n      if (prefs.containsKey(",
  "asBoolFinalUseprefsArgresults": "] as bool;\n    final usePrefs = argResults![",
  "addPatternDisplayCategorizedPatternsForFinalTypeInCategorizedpatternsKeysFinalTypepatternsCategorizedpatternsTypeIfTypepatternsIsnotemptyPrint": "]!.add(pattern);\n            }\n          }\n\n          // Display categorized patterns\n          for (final type in categorizedPatterns.keys) {\n            final typePatterns = categorizedPatterns[type]!;\n            if (typePatterns.isNotEmpty) {\n              print(",
  "emptyString_15": "],\n            ",
  "ifPatternsIsListExcludepatternsPatternsCastStringPrint": "];\n        if (patterns is List) {\n          excludePatterns = patterns.cast<String>();\n          print(\n              ",
  "intlCliScanDirectoryOptions": "intl_cli scan [directory] [options]",
  "response_1": " && response != ",
  "directoryCurrentPathDirAwaitRunfluttergenl10nProjectrootOnFilesystemexceptionCatchEStderrWriteln": " ? Directory.current.path : dir;\n        await _runFlutterGenL10n(projectRoot);\n      } on FileSystemException catch (e) {\n        stderr.writeln(",
  "directoryCurrentPathDirPrint": " ? Directory.current.path : dir;\n    print(",
  "directoryCurrentPathDirectoryPathAwaitRunfluttergenl10nProjectrootCatchInnererrorStderrWriteln": " ? Directory.current.path : directory.path;\n          await _runFlutterGenL10n(projectRoot);\n        } catch (innerError) {\n          stderr.writeln(",
  "ifNoDirectorySpecifiedDir_1": " if no directory specified\n      dir = ",
  "dir_1": "$dir",
  "print_14": ") {\n          print(",
  "eMessageContains": ") ||\n          e.message.contains(",
  "stderrWriteln_1": ")) {\n        stderr.writeln(",
  "emptyString_16": "), ",
  "runFlutterGenL10nToGenerateLocalizationFilesPrint": ");\n\n          // Run flutter gen-l10n to generate localization files\n          print(",
  "ensureDirectoryExistsFinalDirectoryDirectoryPathDirnameArbpathIfDirectoryExistssyncDirectoryCreatesyncRecursiveTrueTryAgainAfterCreatingDirectoryIntlCliGeneratearbfileExtractedstringsArbpathKeyformatFinalkeyformatPrint": ");\n\n        // Ensure directory exists\n        final directory = Directory(path.dirname(arbPath));\n        if (!directory.existsSync()) {\n          directory.createSync(recursive: true);\n        }\n\n        // Try again after creating directory\n        intl_cli.generateArbFile(extractedStrings, arbPath,\n            keyFormat: finalKeyFormat);\n        print(\n            ",
  "runFlutterGenL10nAfterRecoveryPrint": ");\n\n        // Run flutter gen-l10n after recovery\n        print(",
  "runFlutterGenL10nToGenerateLocalizationFilesPrint_1": ");\n\n        // Run flutter gen-l10n to generate localization files\n        print(",
  "exit2ElseExit2CatchEStderrWriteln": ");\n          exit(2);\n        }\n      } else {\n        exit(2);\n      }\n    } catch (e) {\n      stderr.writeln(",
  "finalProjectrootDir": ");\n          final projectRoot = dir == ",
  "returnTryGenerateTheArbFileIntlCliGeneratearbfileExtractedstringsArbpathKeyformatFinalkeyformatPrint": ");\n          return;\n        }\n      }\n\n      try {\n        // Generate the ARB file\n        intl_cli.generateArbFile(extractedStrings, arbPath,\n            keyFormat: finalKeyFormat);\n        print(\n            ",
  "awaitRunfluttergenl10nProjectrootCatchEStderrWriteln": ");\n        await _runFlutterGenL10n(projectRoot);\n      } catch (e) {\n        stderr.writeln(",
  "exit1OnFilesystemexceptionCatchEStderrWriteln": ");\n        exit(1);\n      }\n    } on FileSystemException catch (e) {\n      stderr.writeln(",
  "finalProjectrootDir_1": ");\n        final projectRoot = dir == ",
  "print_15": ");\n        print(",
  "stderrWriteln_2": ");\n        stderr.writeln(",
  "tryGetTheDirectoryPathFromTheErrorFinalDirpathEPathArbpathFinalDirectoryDirectoryPathDirnameDirpathDirectoryCreatesyncRecursiveTrueTryTheOperationAgainIfPathEqualsDirpathDirectoryPathIfTheScanDirectoryWasTheProblemScanAgainFinalNewextractedstringsAwaitIntlCliScandirectoryDirectoryPathIntlCliGeneratearbfileNewextractedstringsArbpathKeyformatFinalkeyformatElseOtherwiseUseTheExistingExtractedStringsButWithTheNewDirectoryIntlCliGeneratearbfileExtractedstringsArbpathKeyformatFinalkeyformatPrint": ");\n        try {\n          // Get the directory path from the error\n          final dirPath = e.path ?? arbPath;\n          final directory = Directory(path.dirname(dirPath));\n          directory.createSync(recursive: true);\n\n          // Try the operation again\n          if (path.equals(dirPath, directory.path)) {\n            // If the scan directory was the problem, scan again\n            final newExtractedStrings = await intl_cli.scanDirectory(directory.path);\n            intl_cli.generateArbFile(newExtractedStrings, arbPath,\n                keyFormat: finalKeyFormat);\n          } else {\n            // Otherwise, use the existing extracted strings but with the new directory\n            intl_cli.generateArbFile(extractedStrings, arbPath,\n                keyFormat: finalKeyFormat);\n          }\n          print(\n              ",
  "tryToRecoverByCreatingTheDirectoryIfEMessageContains": ");\n      // Try to recover by creating the directory\n      if (e.message.contains(",
  "arbpathBaseDeclareThisAtAHigherScopeSoIt": ");\n      arbPath = base;\n    }\n\n    // Declare this at a higher scope so it",
  "exit1Step1EnsureFlutterLocalizationDependenciesArePresentPrint": ");\n      exit(1);\n    }\n\n    // Step 1: Ensure Flutter localization dependencies are present\n    print(",
  "exit1FutureVoidRunfluttergenl10nStringProjectrootAsyncFinalGenresultProcessRunsync": ");\n      exit(1);\n    }\n  }\n\n  Future<void> _runFlutterGenL10n(String projectRoot) async {\n    final genResult = Process.runSync(",
  "print_16": ");\n      print(",
  "printGenresultStderrExit1Print": ");\n      print(genResult.stderr);\n      exit(1);\n    }\n    print(",
  "saveTheCurrentValuesAsPreferencesPrefs": ");\n      }\n\n      // Save the current values as preferences\n      prefs[",
  "argparserAddoption": ");\n    argParser.addOption(",
  "finalDepresultEnsureflutterlocalizationsdependencysafeDirIfDepresultPrint": ");\n    final depResult = ensureFlutterLocalizationsDependencySafe(dir);\n    if (!depResult) {\n      print(",
  "finalProjectrootDir_2": ");\n    final projectRoot = dir == ",
  "finalSetupresultSetupflutterlocalizationconfigurationProjectrootIfSetupresultPrint": ");\n    final setupResult = setupFlutterLocalizationConfiguration(projectRoot);\n    if (!setupResult) {\n      print(",
  "step2SetupCompleteFlutterLocalizationConfigurationPrint": ");\n    }\n\n    // Step 2: Setup complete Flutter localization configuration\n    print(",
  "validateDirectoryExistsIfDirectoryDirExistssyncPrint_1": ");\n    }\n\n    // Validate directory exists\n    if (!Directory(dir).existsSync()) {\n      print(",
  "varOutputArgresults": ");\n    }\n\n    var output = argResults![",
  "elsePrint_12": ");\n    } else {\n      print(",
  "overrideVoidRunAsyncDetermineTheDirectoryToScanCheckPositionalArgsFirstThenDirFlagVarDirArgresultsRestIsnotemptyArgresultsRestFirstArgresults_1": ");\n  }\n\n  @override\n  void run() async {\n    // Determine the directory to scan - check positional args first, then --dir flag\n    var dir = argResults!.rest.isNotEmpty\n        ? argResults!.rest.first\n        : argResults![",
  "abbr_1": ",\n        abbr: ",
  "allowed": ",\n        allowed: [",
  "help_2": ",\n        help: ",
  "emptyString_17": ", [",
  "defaultstoFalseHelp": ", defaultsTo: false, help: ",
  "cliRunnerDart_1": "../cli_runner.dart",
  "ifResponse_1": ";\n        if (response != ",
  "usedsavedprefsTrueIfUsedsavedprefsPrint": ";\n        usedSavedPrefs = true;\n      }\n\n      if (usedSavedPrefs) {\n        print(",
  "print_17": ";\n      print(",
  "featureModuleNameForScopedArbFileEGLoginLibL10nFeatureLoginArb": "Feature/module name for scoped ARB file (e.g., login -> lib/l10n/feature_login.arb)",
  "generateArbFilesFromHardcodedStrings": "Generate ARB files from hardcoded strings",
  "keyNamingConventionSnakeCaseCamelcaseDotCaseDefaultsToSavedPreferences": "Key naming convention: snake_case, camelCase, dot.case (defaults to saved preferences)",
  "noTranslatableStringsFoundInDirNothingToGenerate": "No translatable strings found in $dir. Nothing to generate.",
  "scanningDirectoryDir": "Scanning directory: $dir",
  "nfoundTotalstringsTranslatableStringsInU001b32mExtractedstringsLengthU001b0mFiles": "\\nFound $totalStrings translatable strings in \\u001b[32m${extractedStrings.length}\\u001b[0m files.",
  "nthisWillGenerateAnArbFileWithTotalstringsStringsAtArbpathContinueYN": "\\nThis will generate an ARB file with $totalStrings strings at $arbPath. Continue? (y/N): ",
  "keyformatPrefs": "] = keyFormat;\n      prefs[",
  "pathDirnameOutputPreferencesmanagerSavepreferencesPrefsEnsureValuesAreNotNullAtThisPointFinalFinaloutputOutputFinalFinalkeyformatKeyformatStringArbpathFinaloutputIfScopeNullScopeIsnotemptyFinalBaseFinaloutputReplaceallRegexpR": "] = path.dirname(output);\n      PreferencesManager.savePreferences(prefs);\n    }\n\n    // Ensure values are not null at this point\n    final finalOutput = output;\n    final finalKeyFormat = keyFormat;\n\n    String arbPath = finalOutput;\n    if (scope != null && scope.isNotEmpty) {\n      final base = finalOutput.replaceAll(\n          RegExp(r",
  "asStringIfDirNullDirIsemptyDefaultTo_1": "] as String?;\n\n    if (dir == null || dir.isEmpty) {\n      // Default to ",
  "asStringFinalScopeArgresults": "] as String?;\n    final scope = argResults![",
  "asStringFinalSkipconfirmationArgresults": "] as String?;\n    final skipConfirmation = argResults![",
  "asStringVarKeyformatArgresults": "] as String?;\n    var keyFormat = argResults![",
  "asBoolLoadUserPreferencesIfOptionsWeren": "] as bool;\n\n    // Load user preferences if options weren",
  "workingdirectoryProjectrootIfGenresultExitcode0Print": "], workingDirectory: projectRoot);\n    if (genResult.exitCode != 0) {\n      print(",
  "dotCase": "dot.case",
  "generateTrue_1": "generate: true",
  "intlCliGenerateDirectoryOptions": "intl_cli generate [directory] [options]",
  "reOnlyGeneratingEnglishForNowOutput": "re only generating English for now\n        output = ",
  "response_2": " && response != ",
  "doesNotExistU001b0m": " does not exist.\\u001b[0m",
  "ifNoDirectorySpecifiedDir_2": " if no directory specified\n      dir = ",
  "basedirAppEnArb": "$baseDir/app_en.arb",
  "print_18": ") {\n          print(",
  "contentContentReplaceall": ")) {\n          content = content.replaceAll(\n            ",
  "english": "), // English\n      ],",
  "detectPackageNameFromTheDirectoryStructureFinalPackagenameDetectpackagenameDirPrint": ");\n\n      // Detect package name from the directory structure\n      final packageName = detectPackageName(dir);\n      print(",
  "step5RefactorCodeToUseLocalizationPrint": ");\n\n      // Step 5: Refactor code to use localization\n      print(",
  "finalRefactoredfilesIntlCliRefactorfilesExtractedstringsUseapplocalizationsUseapplocalizationsPackagenamePackagenameStep6RunFlutterPubGetPrint": ");\n\n      final refactoredFiles = intl_cli.refactorFiles(\n        extractedStrings,\n        useAppLocalizations: useAppLocalizations,\n        packageName: packageName,\n      );\n\n      // Step 6: Run flutter pub get\n      print(",
  "print_19": ");\n      \n      print(",
  "returnStep4GenerateArbFilePrint": ");\n          return;\n        }\n      }\n\n      // Step 4: Generate ARB file\n      print(",
  "maindartWriteasstringsyncContentPrint": ");\n        }\n\n        mainDart.writeAsStringSync(content);\n        print(",
  "import": ");\n        }\n //import ",
  "finalPubgetresultProcessRunsync": ");\n      final pubGetResult = Process.runSync(",
  "intlCliGeneratearbfileExtractedstringsOutputKeyformatKeyformatPrint": ");\n      intl_cli.generateArbFile(extractedStrings, output, keyFormat: keyFormat);\n      print(",
  "print_20": ");\n      print(",
  "print_21": ");\n      }\n\n      print(",
  "argparserAddflag_1": ");\n    argParser.addFlag(",
  "argparserAddoption_1": ");\n    argParser.addOption(",
  "makeSureWe": ");\n    }\n\n    // Make sure we",
  "catchEPrint_7": ");\n    } catch (e) {\n      print(",
  "overrideFutureVoidRunAsyncDetermineTheDirectoryToProcessCheckPositionalArgsFirstThenDirFlagVarDirArgresultsRestIsnotemptyArgresultsRestFirstArgresults": ");\n  }\n\n  @override\n  Future<void> run() async {\n    // Determine the directory to process - check positional args first, then --dir flag\n    var dir = argResults!.rest.isNotEmpty\n        ? argResults!.rest.first\n        : argResults![",
  "emptyString_18": ",\n            ",
  "abbr_2": ",\n        abbr: ",
  "allowed_1": ",\n        allowed: [",
  "defaultstoTrueHelp_1": ",\n        defaultsTo: true,\n        help: ",
  "help_3": ",\n        help:\n            ",
  "help_4": ",\n        help: ",
  "emptyString_19": ", [",
  "defaultstoFalseHelp_1": ", defaultsTo: false, help: ",
  "pathRelativeFileFromDirStringsLengthStrings": "- ${path.relative(file, from: dir)} (${strings.length} strings)",
  "keyFormatU001b32mKeyformatU001b0m": "- Key format: \\u001b[32m$keyFormat\\u001b[0m",
  "outputFileU001b32mOutputU001b0mN": "- Output file: \\u001b[32m$output\\u001b[0m\\n",
  "cliRunnerDart_2": "../cli_runner.dart",
  "arb": ".arb",
  "createTheL10nDirectoryIfItDoesn": ";\n        // Create the l10n directory if it doesn",
  "ifContentContains": ";\n        if (!content.contains(",
  "ifResponse_2": ";\n        if (response != ",
  "print_22": ";\n      print(",
  "import_1": ";\nimport ",
  "commandNameDetectedAsDirectoryDefaultingToU001b32mDirU001b0m": "Command name detected as directory, defaulting to: \\u001b[32m$dir\\u001b[0m",
  "completeInternationalizationWorkflowScanExtractStringsRefactorCodeAndGenerateArbFiles": "Complete internationalization workflow: scan, extract strings, refactor code, and generate ARB files",
  "keyNamingConventionSnakeCaseCamelcaseDotCaseDefaultsToSavedPreferences_1": "Key naming convention: snake_case, camelCase, dot.case (defaults to saved preferences)",
  "materialappLocalizationsdelegatesConstApplocalizationsDelegateGlobalmateriallocalizationsDelegateGlobalwidgetslocalizationsDelegateGlobalcupertinolocalizationsDelegateSupportedlocalesConstLocale": "MaterialApp(\n      localizationsDelegates: const [\n        AppLocalizations.delegate,\n        GlobalMaterialLocalizations.delegate,\n        GlobalWidgetsLocalizations.delegate,\n        GlobalCupertinoLocalizations.delegate,\n      ],\n      supportedLocales: const [\n        Locale(",
  "noTranslatableStringsFoundInDirNothingToProcess": "No translatable strings found in $dir. Nothing to process.",
  "nfoundTotalstringsTranslatableStringsInExtractedstringsLengthFiles": "\\nFound $totalStrings translatable strings in ${extractedStrings.length} files:",
  "nthisWillProcessTotalstringsStringsAcrossExtractedstringsLengthFilesContinueYN": "\\nThis will process $totalStrings strings across ${extractedStrings.length} files. Continue? (y/N): ",
  "nU001b36mstep2SettingUpFlutterLocalizationConfigurationU001b0m": "\\n\\u001b[36mStep 2: Setting up Flutter localization configuration...\\u001b[0m",
  "nU001b36musingPreferencesU001b0m": "\\n\\u001b[36mUsing preferences:\\u001b[0m",
  "nStep3ScanningDirectoryForStrings": "\\n📝 Step 3: Scanning directory for strings...",
  "nStep8AddingLocalizationSupportToMaterialapp": "\\n📝 Step 8: Adding localization support to MaterialApp...",
  "nStep7GeneratingLocalizationFiles": "\\n📦 Step 7: Generating localization files...",
  "u001b31merrorRunningFlutterGenL10nU001b0m": "\\u001b[31mError running flutter gen-l10n:\\u001b[0m",
  "u001b31merrorRunningFlutterPubGetU001b0m": "\\u001b[31mError running flutter pub get:\\u001b[0m",
  "u001b31merrorDirectory": "\\u001b[31mError: Directory ",
  "u001b31merrorFailedToSetupFlutterLocalizationConfigurationU001b0m": "\\u001b[31mError: Failed to setup Flutter localization configuration\\u001b[0m",
  "u001b31merrorFailedToSetupRequiredDependenciesU001b0m": "\\u001b[31mError: Failed to setup required dependencies\\u001b[0m",
  "u001b32mDependenciesConfiguredSuccessfullyU001b0m": "\\u001b[32m✓ Dependencies configured successfully\\u001b[0m",
  "u001b32mFlutterLocalizationConfigurationCompletedSuccessfullyU001b0m": "\\u001b[32m✓ Flutter localization configuration completed successfully\\u001b[0m",
  "u001b33mCouldNotRemoveOldArbFilePathBasenameFilePathEU001b0m": "\\u001b[33m⚠️  Could not remove old ARB file ${path.basename(file.path)}: $e\\u001b[0m",
  "u001b36mstep1CheckingAndSettingUpDependenciesU001b0m": "\\u001b[36mStep 1: Checking and setting up dependencies...\\u001b[0m",
  "u001b36mPleaseMakeSureBothFlutterLocalizationsAndIntlAreAddedToPubspecYamlU001b0m": "\\u001b[36mℹ️  Please make sure both flutter_localizations and intl are added to pubspec.yaml\\u001b[0m",
  "u001b36mProjectRootDirectoryProjectrootU001b0m": "\\u001b[36mℹ️  Project root directory: $projectRoot\\u001b[0m",
  "asStringIfOutputNullFinalBasedir": "] as String;\n\n      if (output == null) {\n        final baseDir = ",
  "asStringIfDirNullDirIsemptyDefaultTo_2": "] as String?;\n\n    if (dir == null || dir.isEmpty) {\n      // Default to ",
  "dotCase_1": "dot.case",
  "genL10n": "gen-l10n",
  "import_2": "import ",
  "import_3": "import \\",
  "intlCliInternationalizeDirectoryOptions": "intl_cli internationalize [directory] [options]",
  "keyFormat": "key-format",
  "mainDart": "main.dart",
  "tExplicitlyProvidedIfKeyformatNullOutputNullFinalPrefsAwaitPreferencesmanagerPromptforpreferencesKeyformatPrefs": "t explicitly provided\n    if (keyFormat == null || output == null) {\n      final prefs = await PreferencesManager.promptForPreferences();\n\n      keyFormat ??= prefs[",
  "useAppLocalizations": "use-app-localizations",
  "dependenciesUpdated": "✅ Dependencies updated",
  "localizationFilesGenerated": "✅ Localization files generated",
  "createdDirectoryOutputdirPath": "✓ Created directory: ${outputDir.path}",
  "createdL10nDirectoryAtBasedir": "✓ Created l10n directory at: $baseDir",
  "removedOldArbFilePathBasenameFilePath": "✓ Removed old ARB file: ${path.basename(file.path)}",
  "castFileTolistIfArbfilesIsemptyPrint": "))\n          .cast<File>()\n          .toList();\n\n      if (arbFiles.isEmpty) {\n        print(",
  "forFinalFileInArbfilesPrint": ");\n\n      for (final file in arbFiles) {\n        print(",
  "finalArbfilesArbdirListsyncWhereEntityEntityIsFileEntityPathEndswith": ");\n      \n      final arbFiles = arbDir\n          .listSync()\n          .where((entity) => entity is File && entity.path.endsWith(",
  "arbgeneratorCleaninvalidentriesFilePathPrint": ");\n        ArbGenerator.cleanInvalidEntries(file.path);\n        print(",
  "exit1Print": ");\n        exit(1);\n      }\n\n      print(",
  "returnPrint": ");\n        return;\n      }\n\n      print(",
  "arbgeneratorCleaninvalidentriesSpecificfileElseCleanAllArbFilesInDirectoryFinalArbdirDirectoryDirIfArbdirExistssyncPrint": ");\n      ArbGenerator.cleanInvalidEntries(specificFile);\n    } else {\n      // Clean all ARB files in directory\n      final arbDir = Directory(dir);\n      \n      if (!arbDir.existsSync()) {\n        print(",
  "forFinalFileInArbfilesPrint_1": ");\n      for (final file in arbFiles) {\n        print(",
  "print_23": ");\n      }\n\n      print(",
  "print_24": ");\n      }\n      print(",
  "argparserAddoption_2": ");\n    argParser.addOption(",
  "overrideVoidRunAsyncFinalSpecificfileArgresults": ");\n  }\n\n  @override\n  void run() async {\n    final specificFile = argResults![",
  "abbr_3": ",\n        abbr: ",
  "help_5": ",\n        help: ",
  "cliRunnerDart_3": "../cli_runner.dart",
  "ifSpecificfileNullCleanSpecificFilePrint": ";\n\n    if (specificFile != null) {\n      // Clean specific file\n      print(",
  "cleanArbFilesByRemovingEntriesWithInvalidIcuSyntax": "Clean ARB files by removing entries with invalid ICU syntax",
  "asString": "] as String? ?? ",
  "asStringFinalDirArgresults": "] as String?;\n    final dir = argResults![",
  "intlCliCleanOptions": "intl_cli clean [options]",
  "addall_1": " || addAll == ",
  "confirm_1": " || confirm == ",
  "managepatterns_1": " || managePatterns == ",
  "response_3": " || response == ",
  "category_1": "$category",
  "prefs_1": ") &&\n        prefs[",
  "addAllPatternsFromTheCategoryForFinalPatternInCategorypatternsIfPatternsContainsPatternPatternsAddPatternPrefs_1": ") {\n                // Add all patterns from the category\n                for (final pattern in categoryPatterns) {\n                  if (!patterns.contains(pattern)) {\n                    patterns.add(pattern);\n                  }\n                }\n                prefs[",
  "defaultPatternsFinalDefaultpatternsR": ") {\n          // Default patterns\n          final defaultPatterns = [\n            r",
  "saveCurrentPreferencesBeforePatternManagementPreferencesmanagerSavepreferencesPrefsAwaitManageexcludepatternsElseSaveThePreferencesPreferencesmanagerSavepreferencesPrefsPrint": ") {\n      // Save current preferences before pattern management\n      PreferencesManager.savePreferences(prefs);\n      await _manageExcludePatterns();\n    } else {\n      // Save the preferences\n      PreferencesManager.savePreferences(prefs);\n    }\n\n    print(",
  "tryFinalPrefsfileFilePreferencesmanagerLoadpreferences": ") {\n      try {\n        final prefsFile =\n            File(PreferencesManager.loadPreferences()[",
  "tryFinalLastusedDatetimeParsePrefs": ")) {\n      try {\n        final lastUsed = DateTime.parse(prefs[",
  "showTheDefaultPreferencesViewpreferencesCatchEStderrWriteln": ");\n\n        // Show the default preferences\n        _viewPreferences();\n      } catch (e) {\n        stderr.writeln(",
  "displayExcludePatternsIfPrefsContainskey": ");\n\n    // Display exclude patterns\n    if (prefs.containsKey(",
  "finalPrefsMapStringDynamicFromCurrentprefsFinalFormatchoiceStdinReadlinesync": ");\n\n    final prefs = Map<String, dynamic>.from(currentPrefs);\n    final formatChoice = stdin.readLineSync() ?? ",
  "ifPatternsIsemptyPrint_2": ");\n\n    if (patterns.isEmpty) {\n      print(",
  "stdoutWrite_6": ");\n\n    stdout.write(",
  "print_25": ");\n                    print(\n                        ",
  "elsePrint_13": ");\n                    }\n                  } else {\n                    print(",
  "elsePrint_14": ");\n                    } else {\n                      print(\n                          ",
  "elsePrint_15": ");\n                  }\n                }\n              }\n            } else {\n              print(",
  "catchEPrint_8": ");\n                  }\n                } catch (e) {\n                  print(",
  "elsePrint_16": ");\n                  } else {\n                    print(\n                        ",
  "finalPatternstrStdinReadlinesyncIfPatternstrNullPatternstrIsnotemptyFinalPatternindexIntParsePatternstrIfPatternindex1PatternindexCategorypatternsLengthFinalPatternCategorypatternsPatternindex1IfPatternsContainsPatternPatternsAddPatternPrefs_1": ");\n                final patternStr = stdin.readLineSync();\n                if (patternStr != null && patternStr.isNotEmpty) {\n                  final patternIndex = int.parse(patternStr);\n                  if (patternIndex >= 1 &&\n                      patternIndex <= categoryPatterns.length) {\n                    final pattern = categoryPatterns[patternIndex - 1];\n                    if (!patterns.contains(pattern)) {\n                      patterns.add(pattern);\n                      prefs[",
  "finalSampletextStdinReadlinesync_1": ");\n                final sampleText = stdin.readLineSync() ?? ",
  "elsePrint_17": ");\n                }\n              } else {\n                print(",
  "finalAddallStdinReadlinesyncTolowercase_1": ");\n              final addAll = stdin.readLineSync()?.toLowerCase() ?? ",
  "forVarI0ICategorypatternsLengthIPrint_1": ");\n              for (var i = 0; i < categoryPatterns.length; i++) {\n                print(",
  "stdoutWrite_7": ");\n              }\n\n              stdout.write(",
  "catchEPrint_9": ");\n              }\n            } catch (e) {\n              print(",
  "elseAllowSelectingIndividualPatternsStdoutWrite_1": ");\n              } else {\n                // Allow selecting individual patterns\n                stdout.write(\n                    ",
  "elsePrint_18": ");\n              } else {\n                print(",
  "awaitManageexcludepatternsReturnToPatternManagementBreakCase": ");\n            }\n          }\n        }\n        await _manageExcludePatterns(); // Return to pattern management\n        break;\n\n      case ",
  "awaitManageexcludepatternsReturnToThePatternManagementMenuBreakCase": ");\n            }\n          }\n        }\n        await _manageExcludePatterns(); // Return to the pattern management menu\n        break;\n\n      case ",
  "catchEPrint_10": ");\n            }\n          } catch (e) {\n            print(",
  "elsePatternsAddNewpatternPrefs_1": ");\n            } else {\n              patterns.add(newPattern);\n              prefs[",
  "finalIndexstrStdinReadlinesyncIfIndexstrNullIndexstrIsnotemptyTryFinalIndexIntParseIndexstrIfIndex1IndexPatternsLengthFinalPatternPatternsIndex1StdoutWrite_1": ");\n          final indexStr = stdin.readLineSync();\n          if (indexStr != null && indexStr.isNotEmpty) {\n            try {\n              final index = int.parse(indexStr);\n              if (index >= 1 && index <= patterns.length) {\n                final pattern = patterns[index - 1];\n                stdout.write(",
  "finalIndexstrStdinReadlinesyncIfIndexstrNullIndexstrIsnotemptyTryFinalIndexIntParseIndexstrIfIndex1IndexPatternsLengthFinalRemovedpatternPatternsRemoveatIndex1Prefs_1": ");\n          final indexStr = stdin.readLineSync();\n          if (indexStr != null && indexStr.isNotEmpty) {\n            try {\n              final index = int.parse(indexStr);\n              if (index >= 1 && index <= patterns.length) {\n                final removedPattern = patterns.removeAt(index - 1);\n                prefs[",
  "awaitManageexcludepatternsReturnToPatternManagementBreakCase_1": ");\n          }\n        }\n        await _manageExcludePatterns(); // Return to pattern management\n        break;\n\n      case ",
  "awaitManageexcludepatternsReturnToThePatternManagementMenuBreakCase_1": ");\n          }\n        }\n        await _manageExcludePatterns(); // Return to the pattern management menu\n        break;\n\n      case ",
  "exit1ElsePrint": ");\n        exit(1);\n      }\n    } else {\n      print(",
  "finalCategoriesPatterncategoriesKeysTolistForVarI0ICategoriesLengthIPrint_1": ");\n        final categories = patternCategories.keys.toList();\n        for (var i = 0; i < categories.length; i++) {\n          print(",
  "finalCategorystrStdinReadlinesyncIfCategorystrNullCategorystrIsnotemptyTryFinalIndexIntParseCategorystrIfIndex1IndexCategoriesLengthFinalCategoryCategoriesIndex1FinalCategorypatternsPatterncategoriesCategoryPrint_1": ");\n        final categoryStr = stdin.readLineSync();\n        if (categoryStr != null && categoryStr.isNotEmpty) {\n          try {\n            final index = int.parse(categoryStr);\n            if (index >= 1 && index <= categories.length) {\n              final category = categories[index - 1];\n              final categoryPatterns = patternCategories[category]!;\n\n              print(",
  "finalConfirmStdinReadlinesyncTolowercase_1": ");\n        final confirm = stdin.readLineSync()?.toLowerCase() ?? ",
  "finalNewpatternStdinReadlinesyncIfNewpatternNullNewpatternIsnotemptyValidateThePatternIsAValidRegexTryRegexpNewpatternCheckIfPatternAlreadyExistsIfPatternsContainsNewpatternPrint": ");\n        final newPattern = stdin.readLineSync();\n        if (newPattern != null && newPattern.isNotEmpty) {\n          // Validate the pattern is a valid regex\n          try {\n            RegExp(newPattern);\n\n            // Check if pattern already exists\n            if (patterns.contains(newPattern)) {\n              print(",
  "print_26": ");\n        print(",
  "stdinReadlinesyncAwaitManageexcludepatternsReturnToPatternManagementBreakCase": ");\n        stdin.readLineSync();\n        await _manageExcludePatterns(); // Return to pattern management\n        break;\n\n      case ",
  "stdoutWrite_8": ");\n        }\n\n        stdout.write(",
  "awaitManageexcludepatternsReturnToPatternManagementBreakCase_2": ");\n        }\n        await _manageExcludePatterns(); // Return to pattern management\n        break;\n\n      case ",
  "elseStdoutWrite_1": ");\n        } else {\n          stdout\n              .write(",
  "elseStdoutWrite_2": ");\n        } else {\n          stdout.write(\n              ",
  "forVarI0IPatternsLengthIPrint": ");\n      for (var i = 0; i < patterns.length; i++) {\n        print(",
  "displayLastUsedDateIfPrefsContainskey": ");\n      }\n    }\n\n    // Display last used date\n    if (prefs.containsKey(",
  "print_27": ");\n      }\n    }\n\n    print(",
  "catchEIgnoreDateParsingErrorsFutureVoidManageexcludepatternsAsyncFinalPrefsPreferencesmanagerLoadpreferencesListStringPatternsIfPrefsContainskey": ");\n      } catch (e) {\n        // Ignore date parsing errors\n      }\n    }\n  }\n\n  Future<void> _manageExcludePatterns() async {\n    final prefs = PreferencesManager.loadPreferences();\n    List<String> patterns = [];\n\n    if (prefs.containsKey(",
  "displaypreferencesPrefsFinalPrefsfileFilePrefs": ");\n    _displayPreferences(prefs);\n\n    final prefsFile = File(prefs[",
  "displaypreferencesPrefsVoidViewpreferencesFinalPrefsPreferencesmanagerLoadpreferencesPrint": ");\n    _displayPreferences(prefs);\n  }\n\n  void _viewPreferences() {\n    final prefs = PreferencesManager.loadPreferences();\n    print(",
  "argparserAddflag_2": ");\n    argParser.addFlag(",
  "finalManagepatternsStdinReadlinesyncTolowercase_1": ");\n    final managePatterns = stdin.readLineSync()?.toLowerCase() ?? ",
  "finalOptionStdinReadlinesync_1": ");\n    final option = stdin.readLineSync() ?? ",
  "finalOutdirStdinReadlinesyncIfOutdirNullOutdirIsnotemptyPrefs": ");\n    final outDir = stdin.readLineSync();\n    if (outDir != null && outDir.isNotEmpty) {\n      prefs[",
  "finalResponseStdinReadlinesyncTolowercase_1": ");\n    final response = stdin.readLineSync()?.toLowerCase() ?? ",
  "print_28": ");\n    print(",
  "print_29": ");\n    print(\n        ",
  "stdoutWrite_9": ");\n    stdout.write(",
  "futureVoidEditpreferencesAsyncFinalCurrentprefsPreferencesmanagerLoadpreferencesKeyFormatStdoutWrite": ");\n    }\n  }\n\n  Future<void> _editPreferences() async {\n    final currentPrefs = PreferencesManager.loadPreferences();\n\n    // Key format\n    stdout.write(",
  "elseForVarI0IPatternsLengthIPrint_1": ");\n    } else {\n      for (var i = 0; i < patterns.length; i++) {\n        print(",
  "overrideVoidRunAsyncFinalResetArgresults": ");\n  }\n\n  @override\n  void run() async {\n    final reset = argResults![",
  "voidDisplaypreferencesMapStringDynamicPrefsDisplayBasicPreferencesPrint": ");\n  }\n\n  void _displayPreferences(Map<String, dynamic> prefs) {\n    // Display basic preferences\n    print(",
  "abbr_4": ",\n        abbr: ",
  "defaultstoFalseHelp_2": ",\n        defaultsTo: false,\n        help: ",
  "annotationsR_1": ", // Annotations\n        r",
  "assetPathsR_1": ", // Asset paths\n            r",
  "assetPathsR_2": ", // Asset paths\n        r",
  "classReferencesLikeWidgetPropertyR_1": ", // Class references like Widget.property\n        r",
  "colorHexCodesPrefs": ", // Color hex codes\n          ];\n\n          prefs[",
  "colorHexCodes_1": ", // Color hex codes\n      ],\n      ",
  "imageAndDataFilesR_1": ", // Image and data files\n            r",
  "imageAndDataFilesR_2": ", // Image and data files\n        r",
  "numbersR": ", // Numbers\n            r",
  "numbersAndSimpleFormattedNumbersR_1": ", // Numbers and simple formatted numbers\n        r",
  "privateVariables": ", // Private variables\n      ],\n      ",
  "simpleFileExtensionsR": ", // Simple file extensions\n            r",
  "simpleFileExtensions_1": ", // Simple file extensions\n      ],\n      ",
  "simpleFilePathsWithNoSpacesR_1": ", // Simple file paths with no spaces\n            r",
  "simpleFilePathsWithNoSpacesR_2": ", // Simple file paths with no spaces\n        r",
  "uriSchemesR": ", // URI schemes\n            r",
  "uriSchemes_1": ", // URI schemes\n      ],\n      ",
  "urlsR": ", // URLs\n            r",
  "urlsWithHttpHttpsR_1": ", // URLs with http/https\n        r",
  "uuidsPrint": ", // UUIDs\n      ],\n    };\n\n    print(",
  "versionNumbersR_1": ", // Version numbers\n        r",
  "webAddressesR": ", // Web addresses\n            r",
  "webAddressesStartingWithWwwR_1": ", // Web addresses starting with www\n        r",
  "xmlHtmlTagsR_1": ", // XML/HTML tags\n            r",
  "xmlHtmlTagsR_2": ", // XML/HTML tags\n        r",
  "defaultstoFalseHelp_3": ", defaultsTo: false, help: ",
  "defaultstoTrueHelp_2": ", defaultsTo: true, help: ",
  "cliRunnerDart_4": "../cli_runner.dart",
  "showCategoryOptionsPrint_1": ":\n        // Show category options\n        print(",
  "testPatternAgainstSampleTextIfPatternsIsemptyPrint_1": ":\n        // Test pattern against sample text\n        if (patterns.isEmpty) {\n          print(",
  "ifPatternsIsemptyPrint_3": ":\n        if (patterns.isEmpty) {\n          print(",
  "prefs_2": ":\n        prefs[",
  "print_30": ":\n        print(",
  "stdoutWrite_10": ":\n        stdout.write(",
  "r_6": ": [\n        r",
  "tryFinalRegexRegexpPatternFinalMatchesRegexHasmatchSampletextIfMatchesPrint_1": ";\n\n                try {\n                  final regex = RegExp(pattern);\n                  final matches = regex.hasMatch(sampleText);\n\n                  if (matches) {\n                    print(\n                        ",
  "ifAddall_1": ";\n\n              if (addAll == ",
  "ifManagepatterns_1": ";\n\n    if (managePatterns == ",
  "ifResponse_3": ";\n\n    if (response == ",
  "switchOptionCase_1": ";\n\n    switch (option) {\n      case ",
  "breakCase_4": ";\n        break;\n      case ",
  "breakDefaultPrefs": ";\n        break;\n      default:\n        prefs[",
  "ifConfirm_1": ";\n        if (confirm == ",
  "print_31": ";\n        }\n\n        print(",
  "elseIfDifferenceInhours0Timeago": ";\n        } else if (difference.inHours > 0) {\n          timeAgo = ",
  "elseIfDifferenceInminutes0Timeago": ";\n        } else if (difference.inMinutes > 0) {\n          timeAgo = ",
  "elseTimeago": ";\n        } else {\n          timeAgo = ",
  "switchFormatchoiceCase_1": ";\n    switch (formatChoice) {\n      case ",
  "outputDirectoryStdoutWrite_1": ";\n    }\n\n    // Output directory\n    stdout.write(",
  "viewAndManageUserPreferences": "View and manage user preferences",
  "emptyString_20": "] = ",
  "defaultpatternsPreferencesmanagerSavepreferencesPrefsPrint": "] = defaultPatterns;\n          PreferencesManager.savePreferences(prefs);\n          print(",
  "outdirAskIfUserWantsToManageExcludePatternsStdoutWrite_1": "] = outDir;\n    }\n\n    // Ask if user wants to manage exclude patterns\n    stdout.write(",
  "patternsPreferencesmanagerSavepreferencesPrefsPrint": "] = patterns;\n                      PreferencesManager.savePreferences(prefs);\n                      print(",
  "patternsPreferencesmanagerSavepreferencesPrefsPrint_1": "] = patterns;\n                PreferencesManager.savePreferences(prefs);\n                print(",
  "patternsPreferencesmanagerSavepreferencesPrefsPrint_2": "] = patterns;\n              PreferencesManager.savePreferences(prefs);\n              print(",
  "emptyString_21": "] ?? ",
  "asListCastStringPrint": "] as List).cast<String>();\n      print(",
  "asListCastStringListOfCommonPatternCategoriesToOfferToTheUserFinalPatterncategories_1": "] as List).cast<String>();\n    }\n\n    // List of common pattern categories to offer to the user\n    final patternCategories = {\n      ",
  "asStringIfPrefsfileExistssyncPrefsfileDeletesyncPrint": "] as String);\n        if (prefsFile.existsSync()) {\n          prefsFile.deleteSync();\n        }\n        print(",
  "asBoolIfResetResetpreferencesReturnIfEditAwaitEditpreferencesReturnIfPatternsAwaitManageexcludepatternsReturnIfViewViewpreferencesVoidResetpreferencesStdoutWrite": "] as bool;\n\n    if (reset) {\n      _resetPreferences();\n      return;\n    }\n\n    if (edit) {\n      await _editPreferences();\n      return;\n    }\n\n    if (patterns) {\n      await _manageExcludePatterns();\n      return;\n    }\n\n    if (view) {\n      _viewPreferences();\n    }\n  }\n\n  void _resetPreferences() {\n    stdout.write(\n        ",
  "asBoolFinalEditArgresults": "] as bool;\n    final edit = argResults![",
  "asBoolFinalPatternsArgresults": "] as bool;\n    final patterns = argResults![",
  "asBoolFinalViewArgresults": "] as bool;\n    final view = argResults![",
  "isListFinalPatternsPrefs": "] is List) {\n      final patterns = (prefs[",
  "isListPatternsPrefs_1": "] is List) {\n      patterns = (prefs[",
  "finalNowDatetimeNowFinalDifferenceNowDifferenceLastusedStringTimeagoIfDifferenceIndays0Timeago": "]);\n        final now = DateTime.now();\n        final difference = now.difference(lastUsed);\n\n        String timeAgo;\n        if (difference.inDays > 0) {\n          timeAgo = ",
  "response_4": " && response != ",
  "ifNoDirectorySpecifiedDir_3": " if no directory specified\n      dir = ",
  "dir_2": "$dir",
  "print_32": ") {\n          print(",
  "eMessageContains_1": ") ||\n          e.message.contains(",
  "stderrWriteln_3": ")) {\n        stderr.writeln(",
  "alwaysShowWhatWillBeRefactoredForFinalFileInExtractedstringsKeysPrint": ");\n\n      // Always show what will be refactored\n      for (final file in extractedStrings.keys) {\n        print(\n            ",
  "print_33": ");\n            print(",
  "exit2ElseExit2CatchEStderrWriteln_1": ");\n          exit(2);\n        }\n      } else {\n        exit(2);\n      }\n    } catch (e) {\n      stderr.writeln(",
  "returnPerformTheRefactoringDetectPackageNameAutomaticallyIfNotSpecifiedFinalEffectivepackagenamePackagenameIsemptyDetectpackagenameDirPackagenameIfPackagenameIsemptyPrint": ");\n          return;\n        }\n      }\n\n      // Perform the refactoring\n      // Detect package name automatically if not specified\n      final effectivePackageName =\n          packageName.isEmpty ? detectPackageName(dir) : packageName;\n      if (packageName.isEmpty) {\n        print(",
  "catchInnererrorStderrWriteln": ");\n          }\n        } catch (innerError) {\n          stderr.writeln(",
  "elsePrint_19": ");\n          } else {\n            print(",
  "print_34": ");\n        print(",
  "returnIntTotalstrings0ExtractedstringsForeachFileStringsTotalstringsStringsLengthPrint": ");\n        return;\n      }\n\n      int totalStrings = 0;\n      extractedStrings\n          .forEach((file, strings) => totalStrings += strings.length);\n      print(\n          ",
  "tryGetTheDirectoryPathFromTheErrorFinalDirpathEPathDirFinalDirectoryDirectoryPathDirnameDirpathIfDirectoryExistssyncDirectoryCreatesyncRecursiveTrueTryTheOperationAgainFinalNewextractedstringsAwaitIntlCliScandirectoryDirpathPerformTheRefactoringDetectPackageNameAutomaticallyIfNotSpecifiedFinalEffectivepackagenameforrecoveryPackagenameIsemptyDetectpackagenameDirpathPackagenameIntlCliRefactorfilesNewextractedstringsDryrunDryrunUseapplocalizationsUseapplocalizationsPackagenameEffectivepackagenameforrecoveryPreserveconstPreserveconstIfDryrunPrint": ");\n        try {\n          // Get the directory path from the error\n          final dirPath = e.path ?? dir;\n          final directory = Directory(path.dirname(dirPath));\n          if (!directory.existsSync()) {\n            directory.createSync(recursive: true);\n          }\n\n          // Try the operation again\n          final newExtractedStrings = await intl_cli.scanDirectory(dirPath);\n\n          // Perform the refactoring\n          // Detect package name automatically if not specified\n          final effectivePackageNameForRecovery =\n              packageName.isEmpty ? detectPackageName(dirPath) : packageName;\n\n          intl_cli.refactorFiles(\n            newExtractedStrings,\n            dryRun: dryRun,\n            useAppLocalizations: useAppLocalizations,\n            packageName: effectivePackageNameForRecovery,\n            preserveConst: preserveConst,\n          );\n\n          if (dryRun) {\n            print(",
  "tryToRecoverByCreatingTheDirectoryIfEMessageContains_1": ");\n      // Try to recover by creating the directory\n      if (e.message.contains(",
  "exit1EnsureFlutterLocalizationsDependencyIsPresentPrint": ");\n      exit(1);\n    }\n\n    // Ensure flutter_localizations dependency is present\n    print(\n        ",
  "finalExtractedstringsAwaitIntlCliScandirectoryDirIfExtractedstringsIsemptyPrint": ");\n      final extractedStrings = await intl_cli.scanDirectory(dir);\n\n      if (extractedStrings.isEmpty) {\n        print(",
  "intlCliRefactorfilesExtractedstringsDryrunDryrunUseapplocalizationsUseapplocalizationsPackagenameEffectivepackagenamePreserveconstPreserveconstIfDryrunPrint": ");\n      }\n\n      intl_cli.refactorFiles(\n        extractedStrings,\n        dryRun: dryRun,\n        useAppLocalizations: useAppLocalizations,\n        packageName: effectivePackageName,\n        preserveConst: preserveConst,\n      );\n\n      if (dryRun) {\n        print(",
  "onFilesystemexceptionCatchEStderrWriteln_1": ");\n      }\n    } on FileSystemException catch (e) {\n      stderr.writeln(",
  "elsePrint_20": ");\n      } else {\n        print(",
  "argparserAddflag_3": ");\n    argParser.addFlag(",
  "argparserAddoption_3": ");\n    argParser.addOption(",
  "ensureflutterlocalizationsdependencysafeDirFinalDryrunArgresults": ");\n    ensureFlutterLocalizationsDependencySafe(dir);\n\n    final dryRun = argResults![",
  "validateDirectoryExistsIfDirectoryDirExistssyncPrint_2": ");\n    }\n\n    // Validate directory exists\n    if (!Directory(dir).existsSync()) {\n      print(",
  "overrideVoidRunAsyncDetermineTheDirectoryToScanCheckPositionalArgsFirstThenDirFlagVarDirArgresultsRestIsnotemptyArgresultsRestFirstArgresults_2": ");\n  }\n\n  @override\n  void run() async {\n    // Determine the directory to scan - check positional args first, then --dir flag\n    var dir = argResults!.rest.isNotEmpty\n        ? argResults!.rest.first\n        : argResults![",
  "extractedstringsFileLengthStrings": ")} (${extractedStrings[file]!.length} strings)",
  "abbr_5": ",\n        abbr: ",
  "defaultstoFalseHelp_4": ",\n        defaultsTo: false,\n        help: ",
  "defaultstoTrueHelp_3": ",\n        defaultsTo: true,\n        help: ",
  "help_6": ",\n        help:\n            ",
  "help_7": ",\n        help: ",
  "help_8": ", help: ",
  "cliRunnerDart_5": "../cli_runner.dart",
  "ifResponse_4": ";\n        if (response != ",
  "print_35": ";\n      print(",
  "finalPreserveconstArgresults": ";\n    final preserveConst = argResults![",
  "refactorHardcodedStringsToUseLocalization": "Refactor hardcoded strings to use localization",
  "nthisWillRefactorTotalstringsStringsAcrossExtractedstringsLengthFilesContinueYN": "\\nThis will refactor $totalStrings strings across ${extractedStrings.length} files. Continue? (y/N): ",
  "asString_1": "] as String? ?? ",
  "asStringIfDirNullDirIsemptyDefaultTo_3": "] as String?;\n\n    if (dir == null || dir.isEmpty) {\n      // Default to ",
  "asBoolTryPrint": "] as bool;\n\n    try {\n      print(",
  "asBoolFinalSkipconfirmationArgresults": "] as bool;\n    final skipConfirmation = argResults![",
  "asBoolVarPackagenameArgresults": "] as bool;\n    var packageName = argResults![",
  "asBoolVarUseapplocalizationsArgresults": "] as bool;\n    var useAppLocalizations = argResults![",
  "intlCliRefactorDirectoryOptions": "intl_cli refactor [directory] [options]",
  "emptyString_22": "\n              : ",
  "importpatternNNContent": "$importPattern\\n\\n$content",
  "original": "$original",
  "widgetArgsReplaceall": "$widget(${args.replaceAll(",
  "contentSubstring0LastimportEndNImportpatternContentSubstringLastimportEnd": "${content.substring(0, lastImport.end)}\\n$importPattern${content.substring(lastImport.end)}",
  "constSTextMytextCustomtextLabelLocalizedtextSS": "(const\\s+)?((?:Text|MyText|CustomText|Label|LocalizedText)\\s*(?:<[^>]*>)?)\\s*\\(([^)]*)\\)",
  "argsContains": ") || args.contains(",
  "bufferWrite": ")) {\n            buffer.write(",
  "changesmadeTrueReplacedTrueAlwaysValidateTheKeyFinalValidkeyKeyIsvalidkeyKeyKeyTovalidkeyGenerateTheReplacementUsingApplocalizationsFinalReplacementUsesnullassertion": ")) {\n          changesMade = true;\n          replaced = true;\n\n          // Always validate the key\n          final validKey = key.isValidKey() ? key : key.toValidKey();\n          \n          // Generate the replacement using AppLocalizations\n          final replacement = usesNullAssertion\n              ? ",
  "multilineTrueFinalImportpattern": ", multiLine: true);\n\n    final importPattern = ",
  "replacement": ", replacement)})",
  "applocalizationsRequiresContextSoWeCan": ";\n\n          // AppLocalizations requires context, so we can",
  "ifImportAlreadyExistsDon": ";\n\n    // If import already exists, don",
  "bufferWriteContentSubstringLastmatchMatchStartVarReplacedFalseForFinalEntryInReplacementsEntriesFinalOriginalEntryKeyFinalKeyEntryValueHandleBothDoubleAndSingleQuotesIfArgsContains": ";\n      \n      buffer.write(content.substring(lastMatch, match.start));\n\n      var replaced = false;\n      for (final entry in replacements.entries) {\n        final original = entry.key;\n        final key = entry.value;\n\n        // Handle both double and single quotes\n        if (args.contains(",
  "finalArgsMatchGroup3": ";\n      final args = match.group(3) ?? ",
  "applocalizationsOfContext": "AppLocalizations.of(context)!.",
  "emptyString_23": "].*?[",
  "extensionsStringExtensionsDart": "extensions/string_extensions.dart",
  "importS": "import\\\\s+["
}